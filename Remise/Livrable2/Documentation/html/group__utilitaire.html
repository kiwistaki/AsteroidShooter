<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>My Project: Utilitaire</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utilitaire</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceaidecollision"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaidecollision.html">aidecollision</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceaidegl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaidegl.html">aidegl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceutilitaire"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilitaire.html">utilitaire</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemath"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemath.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevue"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevue.html">vue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette classe contient des methodes &lt; permettant d'ecrire dans un fichier binaire des variables string, double, float, int, unsigned int, char, bool.  <a href="class_c_ecriture_fichier_binaire.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">cette classe contient des methodes &gt; permettant de lire dans un fichier binaire des variables de types string, double, float, int, unsigned int, char, et bool.  <a href="class_c_lecture_fichier_binaire.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classe qui represente l'etat des variables de la machine OpenGL.  <a href="class_etat_open_g_l.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_singleton.html">Singleton&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette classe represente une base generique pour la declaration de singleton.  <a href="class_singleton.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vecteur.html">Vecteur&lt; T, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vecteur2_d.html">Vecteur2D&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vecteur3_d.html">Vecteur3D&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vecteur4_d.html">Vecteur4D&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae90f81f48642444b4ba7fa5cacf40569"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae90f81f48642444b4ba7fa5cacf40569">GL_CLAMP_TO_EDGE</a>&#160;&#160;&#160;0x812F</td></tr>
<tr class="separator:gae90f81f48642444b4ba7fa5cacf40569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849df54224f798741d3fe046180dddfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga849df54224f798741d3fe046180dddfc">COMPARER_VALEUR</a>(<a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>, chaine)&#160;&#160;&#160;if (<a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a> == chaine) return #chaine ;</td></tr>
<tr class="memdesc:ga849df54224f798741d3fe046180dddfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette macro permet de retourner la chaîne associee a une valeur.  <a href="#ga849df54224f798741d3fe046180dddfc">More...</a><br/></td></tr>
<tr class="separator:ga849df54224f798741d3fe046180dddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd82c66571930dca394095824ff37a5c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gacd82c66571930dca394095824ff37a5c">COMPARER_DEFAUT</a>(<a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>)&#160;&#160;&#160;return &quot;GL_??? (&quot; + utilitaire::convertirEnChaine(<a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>) + &quot;)&quot;;</td></tr>
<tr class="memdesc:gacd82c66571930dca394095824ff37a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette macro retourne la valeur par defaut de la variable.  <a href="#gacd82c66571930dca394095824ff37a5c">More...</a><br/></td></tr>
<tr class="separator:gacd82c66571930dca394095824ff37a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e4ee9d5709f277c392eea80755d85d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1e4ee9d5709f277c392eea80755d85d0">SINGLETON_DECLARATION_CLASSE</a>(Classe)</td></tr>
<tr class="separator:ga1e4ee9d5709f277c392eea80755d85d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5462d4b058b18eaee177c1f3f50964"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4e5462d4b058b18eaee177c1f3f50964">SINGLETON_DECLARATION_CLASSE_SANS_CONSTRUCTEUR</a>(Classe)</td></tr>
<tr class="separator:ga4e5462d4b058b18eaee177c1f3f50964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd88a0bb7182bc9164ab9200f31e6340"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gafd88a0bb7182bc9164ab9200f31e6340">SINGLETON_DECLARATION_CPP</a>(Classe)&#160;&#160;&#160;Classe * <a class="el" href="class_singleton.html">Singleton</a>&lt; Classe &gt;::instance_ = 0; \</td></tr>
<tr class="separator:gafd88a0bb7182bc9164ab9200f31e6340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e8b3c8482e593df0ace933ad3de22ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7e8b3c8482e593df0ace933ad3de22ee">RATIO</a>&#160;&#160;&#160;(16.0f/9.0f)</td></tr>
<tr class="separator:ga7e8b3c8482e593df0ace933ad3de22ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6f7808e68c967b90bd7e737b7e1b78de"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_vecteur2_d.html">Vecteur2D</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6f7808e68c967b90bd7e737b7e1b78de">Vecteur2</a></td></tr>
<tr class="memdesc:ga6f7808e68c967b90bd7e737b7e1b78de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition de type de vecteur a 2 coordonnees de type double.  <a href="#ga6f7808e68c967b90bd7e737b7e1b78de">More...</a><br/></td></tr>
<tr class="separator:ga6f7808e68c967b90bd7e737b7e1b78de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541aa4837ad9250d3a248dc82ee9ad4d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_vecteur3_d.html">Vecteur3D</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga541aa4837ad9250d3a248dc82ee9ad4d">Vecteur3</a></td></tr>
<tr class="memdesc:ga541aa4837ad9250d3a248dc82ee9ad4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition de type de vecteur a 3 coordonnees de type double.  <a href="#ga541aa4837ad9250d3a248dc82ee9ad4d">More...</a><br/></td></tr>
<tr class="separator:ga541aa4837ad9250d3a248dc82ee9ad4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74210b298fac77de71eff58f3dd3ddb6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_vecteur4_d.html">Vecteur4D</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga74210b298fac77de71eff58f3dd3ddb6">Vecteur4</a></td></tr>
<tr class="memdesc:ga74210b298fac77de71eff58f3dd3ddb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition de type de vecteur a 4 coordonnees de type double.  <a href="#ga74210b298fac77de71eff58f3dd3ddb6">More...</a><br/></td></tr>
<tr class="separator:ga74210b298fac77de71eff58f3dd3ddb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606b191c0b0bbb868ae25c13b906f45a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_vecteur2_d.html">Vecteur2D</a>&lt; <a class="el" href="fmod_8h.html#aeb841aa4b4b5f444b5d739d865b420af">float</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga606b191c0b0bbb868ae25c13b906f45a">Vecteur2f</a></td></tr>
<tr class="memdesc:ga606b191c0b0bbb868ae25c13b906f45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition de type de vecteur a 2 coordonnees de type float.  <a href="#ga606b191c0b0bbb868ae25c13b906f45a">More...</a><br/></td></tr>
<tr class="separator:ga606b191c0b0bbb868ae25c13b906f45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2956069f76c7e27df4f79f87e5a48c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_vecteur3_d.html">Vecteur3D</a>&lt; <a class="el" href="fmod_8h.html#aeb841aa4b4b5f444b5d739d865b420af">float</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6b2956069f76c7e27df4f79f87e5a48c">Vecteur3f</a></td></tr>
<tr class="memdesc:ga6b2956069f76c7e27df4f79f87e5a48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition de type de vecteur a 3 coordonnees de type float.  <a href="#ga6b2956069f76c7e27df4f79f87e5a48c">More...</a><br/></td></tr>
<tr class="separator:ga6b2956069f76c7e27df4f79f87e5a48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8205c734fc1c9d1272ea424efb2606"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_vecteur4_d.html">Vecteur4D</a>&lt; <a class="el" href="fmod_8h.html#aeb841aa4b4b5f444b5d739d865b420af">float</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6a8205c734fc1c9d1272ea424efb2606">Vecteur4f</a></td></tr>
<tr class="memdesc:ga6a8205c734fc1c9d1272ea424efb2606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition de type de vecteur a 4 coordonnees de type float.  <a href="#ga6a8205c734fc1c9d1272ea424efb2606">More...</a><br/></td></tr>
<tr class="separator:ga6a8205c734fc1c9d1272ea424efb2606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec90ef57a6e09fb50982434719093ccf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_vecteur2_d.html">Vecteur2D</a>&lt; <a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaec90ef57a6e09fb50982434719093ccf">Vecteur2i</a></td></tr>
<tr class="memdesc:gaec90ef57a6e09fb50982434719093ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition de type de vecteur a 2 coordonnees de type int.  <a href="#gaec90ef57a6e09fb50982434719093ccf">More...</a><br/></td></tr>
<tr class="separator:gaec90ef57a6e09fb50982434719093ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba46df25fc97cf509fc2d1f89dc9674"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_vecteur3_d.html">Vecteur3D</a>&lt; <a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5ba46df25fc97cf509fc2d1f89dc9674">Vecteur3i</a></td></tr>
<tr class="memdesc:ga5ba46df25fc97cf509fc2d1f89dc9674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition de type de vecteur a 3 coordonnees de type int.  <a href="#ga5ba46df25fc97cf509fc2d1f89dc9674">More...</a><br/></td></tr>
<tr class="separator:ga5ba46df25fc97cf509fc2d1f89dc9674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4b5a2b41dda0bd067bf74ae33b473a8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_vecteur4_d.html">Vecteur4D</a>&lt; <a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad4b5a2b41dda0bd067bf74ae33b473a8">Vecteur4i</a></td></tr>
<tr class="memdesc:gad4b5a2b41dda0bd067bf74ae33b473a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition de type de vecteur a 4 coordonnees de type int.  <a href="#gad4b5a2b41dda0bd067bf74ae33b473a8">More...</a><br/></td></tr>
<tr class="separator:gad4b5a2b41dda0bd067bf74ae33b473a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3eb1e87955cdb70cd0b16f217740326b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3eb1e87955cdb70cd0b16f217740326b">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const <a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> &amp;<a class="el" href="glew_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a>)</td></tr>
<tr class="separator:ga3eb1e87955cdb70cd0b16f217740326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04922202c65ecfea992b139fa3ad19ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga04922202c65ecfea992b139fa3ad19ff">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const double &amp;<a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>)</td></tr>
<tr class="separator:ga04922202c65ecfea992b139fa3ad19ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga616de7f95d66959d1a2e3216143180aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga616de7f95d66959d1a2e3216143180aa">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const <a class="el" href="fmod_8h.html#aeb841aa4b4b5f444b5d739d865b420af">float</a> &amp;<a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>)</td></tr>
<tr class="separator:ga616de7f95d66959d1a2e3216143180aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0af1c4869b15575ea9c9567a377776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1c0af1c4869b15575ea9c9567a377776">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const <a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a> &amp;<a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>)</td></tr>
<tr class="separator:ga1c0af1c4869b15575ea9c9567a377776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c96e2902dbd2e7fc766683ae7dd3a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa4c96e2902dbd2e7fc766683ae7dd3a0">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const <a class="el" href="_free_image_8h.html#a425076c7067a1b5166e2cc530e914814">unsigned</a> <a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a> &amp;<a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>)</td></tr>
<tr class="separator:gaa4c96e2902dbd2e7fc766683ae7dd3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df50a83cca6bbfec35053d1b3f08a83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2df50a83cca6bbfec35053d1b3f08a83">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const char &amp;<a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>)</td></tr>
<tr class="separator:ga2df50a83cca6bbfec35053d1b3f08a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7baf907cb1eec95df25008219c34f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5e7baf907cb1eec95df25008219c34f7">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const bool &amp;<a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>)</td></tr>
<tr class="separator:ga5e7baf907cb1eec95df25008219c34f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga810bf15b405f05f3069b97084f61aa95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga810bf15b405f05f3069b97084f61aa95">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;<a class="el" href="glew_8h.html#a83ad0ee7f1e06b59c90271716e689080">in</a>, <a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> &amp;<a class="el" href="glew_8h.html#a4af680a6c683f88ed67b76f207f2e6e4">s</a>)</td></tr>
<tr class="separator:ga810bf15b405f05f3069b97084f61aa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3286b1bfce354ab81b9c5e16318f3726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3286b1bfce354ab81b9c5e16318f3726">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;<a class="el" href="glew_8h.html#a83ad0ee7f1e06b59c90271716e689080">in</a>, double &amp;<a class="el" href="glew_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a>)</td></tr>
<tr class="separator:ga3286b1bfce354ab81b9c5e16318f3726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a0bc917393930593341bc27a7fa51d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga66a0bc917393930593341bc27a7fa51d">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;<a class="el" href="glew_8h.html#a83ad0ee7f1e06b59c90271716e689080">in</a>, <a class="el" href="fmod_8h.html#aeb841aa4b4b5f444b5d739d865b420af">float</a> &amp;<a class="el" href="glew_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a>)</td></tr>
<tr class="separator:ga66a0bc917393930593341bc27a7fa51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cd33d9234f45523dd443b122d897fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga06cd33d9234f45523dd443b122d897fa">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;<a class="el" href="glew_8h.html#a83ad0ee7f1e06b59c90271716e689080">in</a>, <a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a> &amp;<a class="el" href="glew_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a>)</td></tr>
<tr class="separator:ga06cd33d9234f45523dd443b122d897fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02d6718459c6e38d1ef0350b209da02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf02d6718459c6e38d1ef0350b209da02">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;<a class="el" href="glew_8h.html#a83ad0ee7f1e06b59c90271716e689080">in</a>, <a class="el" href="_free_image_8h.html#a425076c7067a1b5166e2cc530e914814">unsigned</a> <a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a> &amp;<a class="el" href="glew_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a>)</td></tr>
<tr class="separator:gaf02d6718459c6e38d1ef0350b209da02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81285ae431b1fa84429945395a36f8ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga81285ae431b1fa84429945395a36f8ce">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;<a class="el" href="glew_8h.html#a83ad0ee7f1e06b59c90271716e689080">in</a>, char &amp;<a class="el" href="glew_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a>)</td></tr>
<tr class="separator:ga81285ae431b1fa84429945395a36f8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1585cce945bae21c66998f92f175b115"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1585cce945bae21c66998f92f175b115">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;<a class="el" href="glew_8h.html#a83ad0ee7f1e06b59c90271716e689080">in</a>, bool &amp;<a class="el" href="glew_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a>)</td></tr>
<tr class="separator:ga1585cce945bae21c66998f92f175b115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07715cf8ba84aab7a025770804188a24"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga07715cf8ba84aab7a025770804188a24">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a> &amp;etat)</td></tr>
<tr class="separator:ga07715cf8ba84aab7a025770804188a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5846202001fecd71cd2a0afbbdb494"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5b5846202001fecd71cd2a0afbbdb494">CEcritureFichierBinaire::CEcritureFichierBinaire</a> ()</td></tr>
<tr class="memdesc:ga5b5846202001fecd71cd2a0afbbdb494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par defaut.  <a href="#ga5b5846202001fecd71cd2a0afbbdb494">More...</a><br/></td></tr>
<tr class="separator:ga5b5846202001fecd71cd2a0afbbdb494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad19b9753aa12a9f25fd0febc3c899024"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad19b9753aa12a9f25fd0febc3c899024">CEcritureFichierBinaire::CEcritureFichierBinaire</a> (const char *nomFichier, openmode <a class="el" href="glew_8h.html#a1e71d9c196e4683cc06c4b54d53f7ef5">mode</a>=std::ios::out|<a class="el" href="glew_8h.html#a0ace813ee1f7020974174eb65d53ff0d">std::ios::binary</a>)</td></tr>
<tr class="memdesc:gad19b9753aa12a9f25fd0febc3c899024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par parametre.  <a href="#gad19b9753aa12a9f25fd0febc3c899024">More...</a><br/></td></tr>
<tr class="separator:gad19b9753aa12a9f25fd0febc3c899024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7145545254c30909311d3b1ef0bdd07a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="wglew_8h.html#aeea6e3dfae3acf232096f57d2d57f084">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7145545254c30909311d3b1ef0bdd07a">CEcritureFichierBinaire::null</a> (<a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a> <a class="el" href="glew_8h.html#a4cf5f6946cc0a65dbe0d2406017e469c">n</a>)</td></tr>
<tr class="memdesc:ga7145545254c30909311d3b1ef0bdd07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction pour inserer des caracteres vides dans le fichier.  <a href="#ga7145545254c30909311d3b1ef0bdd07a">More...</a><br/></td></tr>
<tr class="separator:ga7145545254c30909311d3b1ef0bdd07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a259905a2c14513846e6ecb8cf476ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3a259905a2c14513846e6ecb8cf476ad">CLectureFichierBinaire::CLectureFichierBinaire</a> ()</td></tr>
<tr class="memdesc:ga3a259905a2c14513846e6ecb8cf476ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par defaut.  <a href="#ga3a259905a2c14513846e6ecb8cf476ad">More...</a><br/></td></tr>
<tr class="separator:ga3a259905a2c14513846e6ecb8cf476ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac16ebab7b172408c2ba14605f61f0f84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac16ebab7b172408c2ba14605f61f0f84">CLectureFichierBinaire::CLectureFichierBinaire</a> (const char *nomFichier, openmode <a class="el" href="glew_8h.html#a1e71d9c196e4683cc06c4b54d53f7ef5">mode</a>=<a class="el" href="glew_8h.html#a83ad0ee7f1e06b59c90271716e689080">std::ios::in</a>|<a class="el" href="glew_8h.html#a0ace813ee1f7020974174eb65d53ff0d">std::ios::binary</a>)</td></tr>
<tr class="memdesc:gac16ebab7b172408c2ba14605f61f0f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par parametre.  <a href="#gac16ebab7b172408c2ba14605f61f0f84">More...</a><br/></td></tr>
<tr class="separator:gac16ebab7b172408c2ba14605f61f0f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf682f61929f2502b08b6b88de07349b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf682f61929f2502b08b6b88de07349b6">EtatOpenGL::EtatOpenGL</a> ()</td></tr>
<tr class="memdesc:gaf682f61929f2502b08b6b88de07349b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par defaut.  <a href="#gaf682f61929f2502b08b6b88de07349b6">More...</a><br/></td></tr>
<tr class="separator:gaf682f61929f2502b08b6b88de07349b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ddfdab3e65cc4069b86ba84d3f565b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="wglew_8h.html#aeea6e3dfae3acf232096f57d2d57f084">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga24ddfdab3e65cc4069b86ba84d3f565b">EtatOpenGL::obtenirDifference</a> (std::ostream &amp;o, const <a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a> &amp;etat1, const <a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a> &amp;etat2)</td></tr>
<tr class="memdesc:ga24ddfdab3e65cc4069b86ba84d3f565b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare deux etats OpenGL et affiche la difference entre les deux.  <a href="#ga24ddfdab3e65cc4069b86ba84d3f565b">More...</a><br/></td></tr>
<tr class="separator:ga24ddfdab3e65cc4069b86ba84d3f565b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c8aaca9f02431b47b83e36b18f8067"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga13c8aaca9f02431b47b83e36b18f8067">EtatOpenGL::obtenirChaineGlAccumAlphaBits</a> () const </td></tr>
<tr class="memdesc:ga13c8aaca9f02431b47b83e36b18f8067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ACCUM_ALPHA_BITS.  <a href="#ga13c8aaca9f02431b47b83e36b18f8067">More...</a><br/></td></tr>
<tr class="separator:ga13c8aaca9f02431b47b83e36b18f8067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695387ee2d838c97214c70219d52da10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga695387ee2d838c97214c70219d52da10">EtatOpenGL::obtenirChaineGlAccumBlueBits</a> () const </td></tr>
<tr class="memdesc:ga695387ee2d838c97214c70219d52da10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ACCUM_BLUE_BITS.  <a href="#ga695387ee2d838c97214c70219d52da10">More...</a><br/></td></tr>
<tr class="separator:ga695387ee2d838c97214c70219d52da10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3e85f5f434e93aa09376200f3c837ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf3e85f5f434e93aa09376200f3c837ae">EtatOpenGL::obtenirChaineGlAccumClearValue</a> () const </td></tr>
<tr class="memdesc:gaf3e85f5f434e93aa09376200f3c837ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ACCUM_CLEAR_VALUE.  <a href="#gaf3e85f5f434e93aa09376200f3c837ae">More...</a><br/></td></tr>
<tr class="separator:gaf3e85f5f434e93aa09376200f3c837ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae677b60d2113b1843ba4d2c92fe34c34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae677b60d2113b1843ba4d2c92fe34c34">EtatOpenGL::obtenirChaineGlAccumGreenBits</a> () const </td></tr>
<tr class="memdesc:gae677b60d2113b1843ba4d2c92fe34c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ACCUM_GREEN_BITS.  <a href="#gae677b60d2113b1843ba4d2c92fe34c34">More...</a><br/></td></tr>
<tr class="separator:gae677b60d2113b1843ba4d2c92fe34c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3405a98de14c30d7a57d954d298b6376"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3405a98de14c30d7a57d954d298b6376">EtatOpenGL::obtenirChaineGlAccumRedBits</a> () const </td></tr>
<tr class="memdesc:ga3405a98de14c30d7a57d954d298b6376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ACCUM_RED_BITS.  <a href="#ga3405a98de14c30d7a57d954d298b6376">More...</a><br/></td></tr>
<tr class="separator:ga3405a98de14c30d7a57d954d298b6376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf54d9525863334d2d2fd362c7043a4be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf54d9525863334d2d2fd362c7043a4be">EtatOpenGL::obtenirChaineGlAlphaBias</a> () const </td></tr>
<tr class="memdesc:gaf54d9525863334d2d2fd362c7043a4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ALPHA_BIAS.  <a href="#gaf54d9525863334d2d2fd362c7043a4be">More...</a><br/></td></tr>
<tr class="separator:gaf54d9525863334d2d2fd362c7043a4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea311e8cfd6aee3cb19e2041b2ba132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7ea311e8cfd6aee3cb19e2041b2ba132">EtatOpenGL::obtenirChaineGlAlphaBits</a> () const </td></tr>
<tr class="memdesc:ga7ea311e8cfd6aee3cb19e2041b2ba132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ALPHA_BITS.  <a href="#ga7ea311e8cfd6aee3cb19e2041b2ba132">More...</a><br/></td></tr>
<tr class="separator:ga7ea311e8cfd6aee3cb19e2041b2ba132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b85b93cd7e5d1f12a225f28ece00696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3b85b93cd7e5d1f12a225f28ece00696">EtatOpenGL::obtenirChaineGlAlphaScale</a> () const </td></tr>
<tr class="memdesc:ga3b85b93cd7e5d1f12a225f28ece00696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ALPHA_SCALE.  <a href="#ga3b85b93cd7e5d1f12a225f28ece00696">More...</a><br/></td></tr>
<tr class="separator:ga3b85b93cd7e5d1f12a225f28ece00696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fd2e2270997cf027e38f6a7b8d621a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9fd2e2270997cf027e38f6a7b8d621a8">EtatOpenGL::obtenirChaineGlAlphaTest</a> () const </td></tr>
<tr class="memdesc:ga9fd2e2270997cf027e38f6a7b8d621a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ALPHA_TEST.  <a href="#ga9fd2e2270997cf027e38f6a7b8d621a8">More...</a><br/></td></tr>
<tr class="separator:ga9fd2e2270997cf027e38f6a7b8d621a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5002fd87fb9aede24afc4c4bb2a61fb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5002fd87fb9aede24afc4c4bb2a61fb1">EtatOpenGL::obtenirChaineGlAlphaTestFunc</a> () const </td></tr>
<tr class="memdesc:ga5002fd87fb9aede24afc4c4bb2a61fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ALPHA_TEST_FUNC.  <a href="#ga5002fd87fb9aede24afc4c4bb2a61fb1">More...</a><br/></td></tr>
<tr class="separator:ga5002fd87fb9aede24afc4c4bb2a61fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc2904dcf7edec91f24e5e6ea58a780c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gacc2904dcf7edec91f24e5e6ea58a780c">EtatOpenGL::obtenirChaineGlAlphaTestRef</a> () const </td></tr>
<tr class="memdesc:gacc2904dcf7edec91f24e5e6ea58a780c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ALPHA_TEST_REF.  <a href="#gacc2904dcf7edec91f24e5e6ea58a780c">More...</a><br/></td></tr>
<tr class="separator:gacc2904dcf7edec91f24e5e6ea58a780c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59c1e206aa477f625b5499cf328f695b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga59c1e206aa477f625b5499cf328f695b">EtatOpenGL::obtenirChaineGlAttribStackDepth</a> () const </td></tr>
<tr class="memdesc:ga59c1e206aa477f625b5499cf328f695b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ATTRIB_STACK_DEPTH.  <a href="#ga59c1e206aa477f625b5499cf328f695b">More...</a><br/></td></tr>
<tr class="separator:ga59c1e206aa477f625b5499cf328f695b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf8d3f8a4dd51812950c32268c8f77c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaaf8d3f8a4dd51812950c32268c8f77c5">EtatOpenGL::obtenirChaineGlAutoNormal</a> () const </td></tr>
<tr class="memdesc:gaaf8d3f8a4dd51812950c32268c8f77c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_AUTO_NORMAL.  <a href="#gaaf8d3f8a4dd51812950c32268c8f77c5">More...</a><br/></td></tr>
<tr class="separator:gaaf8d3f8a4dd51812950c32268c8f77c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8c780e176faece6cbaa11084e957e8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab8c780e176faece6cbaa11084e957e8d">EtatOpenGL::obtenirChaineGlAuxBuffers</a> () const </td></tr>
<tr class="memdesc:gab8c780e176faece6cbaa11084e957e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_AUX_BUFFERS.  <a href="#gab8c780e176faece6cbaa11084e957e8d">More...</a><br/></td></tr>
<tr class="separator:gab8c780e176faece6cbaa11084e957e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a5f949f2b7a9a911c0677d639bebae5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8a5f949f2b7a9a911c0677d639bebae5">EtatOpenGL::obtenirChaineGlBlend</a> () const </td></tr>
<tr class="memdesc:ga8a5f949f2b7a9a911c0677d639bebae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_BLEND.  <a href="#ga8a5f949f2b7a9a911c0677d639bebae5">More...</a><br/></td></tr>
<tr class="separator:ga8a5f949f2b7a9a911c0677d639bebae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52ab39bcb62d4f8777afddfca458650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa52ab39bcb62d4f8777afddfca458650">EtatOpenGL::obtenirChaineGlBlendDst</a> () const </td></tr>
<tr class="memdesc:gaa52ab39bcb62d4f8777afddfca458650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_BLEND_DST.  <a href="#gaa52ab39bcb62d4f8777afddfca458650">More...</a><br/></td></tr>
<tr class="separator:gaa52ab39bcb62d4f8777afddfca458650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga510a36fe5d3e313756e40b5c67b516ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga510a36fe5d3e313756e40b5c67b516ba">EtatOpenGL::obtenirChaineGlBlendSrc</a> () const </td></tr>
<tr class="memdesc:ga510a36fe5d3e313756e40b5c67b516ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_BLEND_SRC.  <a href="#ga510a36fe5d3e313756e40b5c67b516ba">More...</a><br/></td></tr>
<tr class="separator:ga510a36fe5d3e313756e40b5c67b516ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95f9a6baabd65a0cdd4b1e5cbeb4f678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga95f9a6baabd65a0cdd4b1e5cbeb4f678">EtatOpenGL::obtenirChaineGlBlueBias</a> () const </td></tr>
<tr class="memdesc:ga95f9a6baabd65a0cdd4b1e5cbeb4f678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_BLUE_BIAS.  <a href="#ga95f9a6baabd65a0cdd4b1e5cbeb4f678">More...</a><br/></td></tr>
<tr class="separator:ga95f9a6baabd65a0cdd4b1e5cbeb4f678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125172f1c5c4ef27c20c4e52a70ce38a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga125172f1c5c4ef27c20c4e52a70ce38a">EtatOpenGL::obtenirChaineGlBlueBits</a> () const </td></tr>
<tr class="memdesc:ga125172f1c5c4ef27c20c4e52a70ce38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_BLUE_BITS.  <a href="#ga125172f1c5c4ef27c20c4e52a70ce38a">More...</a><br/></td></tr>
<tr class="separator:ga125172f1c5c4ef27c20c4e52a70ce38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8422f585aba4fc07dcaac22e6cf587b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8422f585aba4fc07dcaac22e6cf587b3">EtatOpenGL::obtenirChaineGlBlueScale</a> () const </td></tr>
<tr class="memdesc:ga8422f585aba4fc07dcaac22e6cf587b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_BLUE_SCALE.  <a href="#ga8422f585aba4fc07dcaac22e6cf587b3">More...</a><br/></td></tr>
<tr class="separator:ga8422f585aba4fc07dcaac22e6cf587b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad57f6d8da9cffeae2204a77e6e5f9292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad57f6d8da9cffeae2204a77e6e5f9292">EtatOpenGL::obtenirChaineGlClientAttribStackDepth</a> () const </td></tr>
<tr class="memdesc:gad57f6d8da9cffeae2204a77e6e5f9292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CLIENT_ATTRIB_STACK_DEPTH.  <a href="#gad57f6d8da9cffeae2204a77e6e5f9292">More...</a><br/></td></tr>
<tr class="separator:gad57f6d8da9cffeae2204a77e6e5f9292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7deb847efbc619585d5e8c9f6600204c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7deb847efbc619585d5e8c9f6600204c">EtatOpenGL::obtenirChaineGlClipPlanei</a> () const </td></tr>
<tr class="memdesc:ga7deb847efbc619585d5e8c9f6600204c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CLIP_PLANEi.  <a href="#ga7deb847efbc619585d5e8c9f6600204c">More...</a><br/></td></tr>
<tr class="separator:ga7deb847efbc619585d5e8c9f6600204c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fae4f702f9be3574209f0721b6768ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8fae4f702f9be3574209f0721b6768ba">EtatOpenGL::obtenirChaineGlColorArray</a> () const </td></tr>
<tr class="memdesc:ga8fae4f702f9be3574209f0721b6768ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_COLOR_ARRAY.  <a href="#ga8fae4f702f9be3574209f0721b6768ba">More...</a><br/></td></tr>
<tr class="separator:ga8fae4f702f9be3574209f0721b6768ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e82d8c71b8e2a76c806e1c92cbb669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad1e82d8c71b8e2a76c806e1c92cbb669">EtatOpenGL::obtenirChaineGlColorArraySize</a> () const </td></tr>
<tr class="memdesc:gad1e82d8c71b8e2a76c806e1c92cbb669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_COLOR_ARRAY_SIZE.  <a href="#gad1e82d8c71b8e2a76c806e1c92cbb669">More...</a><br/></td></tr>
<tr class="separator:gad1e82d8c71b8e2a76c806e1c92cbb669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab499d52456b097364de8300cc6af6808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab499d52456b097364de8300cc6af6808">EtatOpenGL::obtenirChaineGlColorArrayStride</a> () const </td></tr>
<tr class="memdesc:gab499d52456b097364de8300cc6af6808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_COLOR_ARRAY_STRIDE.  <a href="#gab499d52456b097364de8300cc6af6808">More...</a><br/></td></tr>
<tr class="separator:gab499d52456b097364de8300cc6af6808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77f9acd8bdebe2e7bb39660e03b3e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae77f9acd8bdebe2e7bb39660e03b3e28">EtatOpenGL::obtenirChaineGlColorArrayType</a> () const </td></tr>
<tr class="memdesc:gae77f9acd8bdebe2e7bb39660e03b3e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_COLOR_ARRAY_TYPE.  <a href="#gae77f9acd8bdebe2e7bb39660e03b3e28">More...</a><br/></td></tr>
<tr class="separator:gae77f9acd8bdebe2e7bb39660e03b3e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de74c129bd5c5038e7f3d03a5508f72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7de74c129bd5c5038e7f3d03a5508f72">EtatOpenGL::obtenirChaineGlColorClearValue</a> () const </td></tr>
<tr class="memdesc:ga7de74c129bd5c5038e7f3d03a5508f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_COLOR_CLEAR_VALUE.  <a href="#ga7de74c129bd5c5038e7f3d03a5508f72">More...</a><br/></td></tr>
<tr class="separator:ga7de74c129bd5c5038e7f3d03a5508f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac48e5f8e10bfcd96670a537164a0a8ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac48e5f8e10bfcd96670a537164a0a8ff">EtatOpenGL::obtenirChaineGlColorLogicOp</a> () const </td></tr>
<tr class="memdesc:gac48e5f8e10bfcd96670a537164a0a8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_COLOR_LOGIC_OP.  <a href="#gac48e5f8e10bfcd96670a537164a0a8ff">More...</a><br/></td></tr>
<tr class="separator:gac48e5f8e10bfcd96670a537164a0a8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53c823bf9d4e4305baf00f4d7da96af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae53c823bf9d4e4305baf00f4d7da96af">EtatOpenGL::obtenirChaineGlColorMaterial</a> () const </td></tr>
<tr class="memdesc:gae53c823bf9d4e4305baf00f4d7da96af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_COLOR_MATERIAL.  <a href="#gae53c823bf9d4e4305baf00f4d7da96af">More...</a><br/></td></tr>
<tr class="separator:gae53c823bf9d4e4305baf00f4d7da96af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec66f0ae860a11d50b0e1cf2def483bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaec66f0ae860a11d50b0e1cf2def483bf">EtatOpenGL::obtenirChaineGlColorMaterialFace</a> () const </td></tr>
<tr class="memdesc:gaec66f0ae860a11d50b0e1cf2def483bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_COLOR_MATERIAL_FACE.  <a href="#gaec66f0ae860a11d50b0e1cf2def483bf">More...</a><br/></td></tr>
<tr class="separator:gaec66f0ae860a11d50b0e1cf2def483bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2b7f4282f94a24c4b5129854732c36a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad2b7f4282f94a24c4b5129854732c36a">EtatOpenGL::obtenirChaineGlColorMaterialParameter</a> () const </td></tr>
<tr class="memdesc:gad2b7f4282f94a24c4b5129854732c36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_COLOR_MATERIAL_PARAMETER.  <a href="#gad2b7f4282f94a24c4b5129854732c36a">More...</a><br/></td></tr>
<tr class="separator:gad2b7f4282f94a24c4b5129854732c36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677eb5add1db0999f73a7c6febefe4d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga677eb5add1db0999f73a7c6febefe4d8">EtatOpenGL::obtenirChaineGlColorWritemask</a> () const </td></tr>
<tr class="memdesc:ga677eb5add1db0999f73a7c6febefe4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_COLOR_WRITEMASK.  <a href="#ga677eb5add1db0999f73a7c6febefe4d8">More...</a><br/></td></tr>
<tr class="separator:ga677eb5add1db0999f73a7c6febefe4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c53044cfb9b67582efe6415ff1f1f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6c53044cfb9b67582efe6415ff1f1f49">EtatOpenGL::obtenirChaineGlCullFace</a> () const </td></tr>
<tr class="memdesc:ga6c53044cfb9b67582efe6415ff1f1f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CULL_FACE.  <a href="#ga6c53044cfb9b67582efe6415ff1f1f49">More...</a><br/></td></tr>
<tr class="separator:ga6c53044cfb9b67582efe6415ff1f1f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0601a9f84791de8e9ab33841308ecea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga0601a9f84791de8e9ab33841308ecea0">EtatOpenGL::obtenirChaineGlCullFaceMode</a> () const </td></tr>
<tr class="memdesc:ga0601a9f84791de8e9ab33841308ecea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CULL_FACE_MODE.  <a href="#ga0601a9f84791de8e9ab33841308ecea0">More...</a><br/></td></tr>
<tr class="separator:ga0601a9f84791de8e9ab33841308ecea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe349174d65850291bc46f7b524dac44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gabe349174d65850291bc46f7b524dac44">EtatOpenGL::obtenirChaineGlCurrentColor</a> () const </td></tr>
<tr class="memdesc:gabe349174d65850291bc46f7b524dac44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CURRENT_COLOR.  <a href="#gabe349174d65850291bc46f7b524dac44">More...</a><br/></td></tr>
<tr class="separator:gabe349174d65850291bc46f7b524dac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga222790a07e4a9cacfbe2f68cd97fd8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga222790a07e4a9cacfbe2f68cd97fd8d9">EtatOpenGL::obtenirChaineGlCurrentIndex</a> () const </td></tr>
<tr class="memdesc:ga222790a07e4a9cacfbe2f68cd97fd8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CURRENT_INDEX.  <a href="#ga222790a07e4a9cacfbe2f68cd97fd8d9">More...</a><br/></td></tr>
<tr class="separator:ga222790a07e4a9cacfbe2f68cd97fd8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c54789d936998634ad29c80e150d92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac6c54789d936998634ad29c80e150d92">EtatOpenGL::obtenirChaineGlCurrentNormal</a> () const </td></tr>
<tr class="memdesc:gac6c54789d936998634ad29c80e150d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CURRENT_NORMAL.  <a href="#gac6c54789d936998634ad29c80e150d92">More...</a><br/></td></tr>
<tr class="separator:gac6c54789d936998634ad29c80e150d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62ef22c97a3ecc8c7e956f2fd7267b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga62ef22c97a3ecc8c7e956f2fd7267b9d">EtatOpenGL::obtenirChaineGlCurrentRasterColor</a> () const </td></tr>
<tr class="memdesc:ga62ef22c97a3ecc8c7e956f2fd7267b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CURRENT_RASTER_COLOR.  <a href="#ga62ef22c97a3ecc8c7e956f2fd7267b9d">More...</a><br/></td></tr>
<tr class="separator:ga62ef22c97a3ecc8c7e956f2fd7267b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga130c72bf45a65d7d7770c77c7f71cf5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga130c72bf45a65d7d7770c77c7f71cf5c">EtatOpenGL::obtenirChaineGlCurrentRasterDistance</a> () const </td></tr>
<tr class="memdesc:ga130c72bf45a65d7d7770c77c7f71cf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CURRENT_RASTER_DISTANCE.  <a href="#ga130c72bf45a65d7d7770c77c7f71cf5c">More...</a><br/></td></tr>
<tr class="separator:ga130c72bf45a65d7d7770c77c7f71cf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d14728a6f086186ff9ec92738952892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9d14728a6f086186ff9ec92738952892">EtatOpenGL::obtenirChaineGlCurrentRasterIndex</a> () const </td></tr>
<tr class="memdesc:ga9d14728a6f086186ff9ec92738952892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CURRENT_RASTER_INDEX.  <a href="#ga9d14728a6f086186ff9ec92738952892">More...</a><br/></td></tr>
<tr class="separator:ga9d14728a6f086186ff9ec92738952892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1151f4eee3a50e14e0157b18b6fefaa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1151f4eee3a50e14e0157b18b6fefaa4">EtatOpenGL::obtenirChaineGlCurrentRasterPosition</a> () const </td></tr>
<tr class="memdesc:ga1151f4eee3a50e14e0157b18b6fefaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CURRENT_RASTER_POSITION.  <a href="#ga1151f4eee3a50e14e0157b18b6fefaa4">More...</a><br/></td></tr>
<tr class="separator:ga1151f4eee3a50e14e0157b18b6fefaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa95c762062531085430d3bd8381c1ab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa95c762062531085430d3bd8381c1ab1">EtatOpenGL::obtenirChaineGlCurrentRasterPositionValid</a> () const </td></tr>
<tr class="memdesc:gaa95c762062531085430d3bd8381c1ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CURRENT_RASTER_POSITION_VALID.  <a href="#gaa95c762062531085430d3bd8381c1ab1">More...</a><br/></td></tr>
<tr class="separator:gaa95c762062531085430d3bd8381c1ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1b30e504db9237dce13eade239c8c5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae1b30e504db9237dce13eade239c8c5a">EtatOpenGL::obtenirChaineGlCurrentRasterTextureCoords</a> () const </td></tr>
<tr class="memdesc:gae1b30e504db9237dce13eade239c8c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CURRENT_RASTER_TEXTURE_COORDS.  <a href="#gae1b30e504db9237dce13eade239c8c5a">More...</a><br/></td></tr>
<tr class="separator:gae1b30e504db9237dce13eade239c8c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bf6abadfe9d63e576d34c94c93ee8f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5bf6abadfe9d63e576d34c94c93ee8f0">EtatOpenGL::obtenirChaineGlCurrentTextureCoords</a> () const </td></tr>
<tr class="memdesc:ga5bf6abadfe9d63e576d34c94c93ee8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_CURRENT_TEXTURE_COORDS.  <a href="#ga5bf6abadfe9d63e576d34c94c93ee8f0">More...</a><br/></td></tr>
<tr class="separator:ga5bf6abadfe9d63e576d34c94c93ee8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e587b7e9f860f3874823a3c4ab7d71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae3e587b7e9f860f3874823a3c4ab7d71">EtatOpenGL::obtenirChaineGlDepthBias</a> () const </td></tr>
<tr class="memdesc:gae3e587b7e9f860f3874823a3c4ab7d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_DEPTH_BIAS.  <a href="#gae3e587b7e9f860f3874823a3c4ab7d71">More...</a><br/></td></tr>
<tr class="separator:gae3e587b7e9f860f3874823a3c4ab7d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1dffc44c8e27d7cb249064cfe35653e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae1dffc44c8e27d7cb249064cfe35653e">EtatOpenGL::obtenirChaineGlDepthBits</a> () const </td></tr>
<tr class="memdesc:gae1dffc44c8e27d7cb249064cfe35653e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_DEPTH_BITS.  <a href="#gae1dffc44c8e27d7cb249064cfe35653e">More...</a><br/></td></tr>
<tr class="separator:gae1dffc44c8e27d7cb249064cfe35653e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b3e2701fb07b0178b5015868818509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad8b3e2701fb07b0178b5015868818509">EtatOpenGL::obtenirChaineGlDepthClearValue</a> () const </td></tr>
<tr class="memdesc:gad8b3e2701fb07b0178b5015868818509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_DEPTH_CLEAR_VALUE.  <a href="#gad8b3e2701fb07b0178b5015868818509">More...</a><br/></td></tr>
<tr class="separator:gad8b3e2701fb07b0178b5015868818509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0dff9e4aee8f969fe6e688bb407dcc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac0dff9e4aee8f969fe6e688bb407dcc9">EtatOpenGL::obtenirChaineGlDepthFunc</a> () const </td></tr>
<tr class="memdesc:gac0dff9e4aee8f969fe6e688bb407dcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_DEPTH_FUNC.  <a href="#gac0dff9e4aee8f969fe6e688bb407dcc9">More...</a><br/></td></tr>
<tr class="separator:gac0dff9e4aee8f969fe6e688bb407dcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9921b541644f4dc3b64a4ffd4a661a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9921b541644f4dc3b64a4ffd4a661a09">EtatOpenGL::obtenirChaineGlDepthRange</a> () const </td></tr>
<tr class="memdesc:ga9921b541644f4dc3b64a4ffd4a661a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_DEPTH_RANGE.  <a href="#ga9921b541644f4dc3b64a4ffd4a661a09">More...</a><br/></td></tr>
<tr class="separator:ga9921b541644f4dc3b64a4ffd4a661a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fac162003ef8c012c16ecd9041794ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4fac162003ef8c012c16ecd9041794ae">EtatOpenGL::obtenirChaineGlDepthScale</a> () const </td></tr>
<tr class="memdesc:ga4fac162003ef8c012c16ecd9041794ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_DEPTH_SCALE.  <a href="#ga4fac162003ef8c012c16ecd9041794ae">More...</a><br/></td></tr>
<tr class="separator:ga4fac162003ef8c012c16ecd9041794ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga712bcce1fd6c63377d2b3c9c421f7559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga712bcce1fd6c63377d2b3c9c421f7559">EtatOpenGL::obtenirChaineGlDepthTest</a> () const </td></tr>
<tr class="memdesc:ga712bcce1fd6c63377d2b3c9c421f7559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_DEPTH_TEST.  <a href="#ga712bcce1fd6c63377d2b3c9c421f7559">More...</a><br/></td></tr>
<tr class="separator:ga712bcce1fd6c63377d2b3c9c421f7559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec88db9c85bfd66909d3172982025862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaec88db9c85bfd66909d3172982025862">EtatOpenGL::obtenirChaineGlDepthWritemask</a> () const </td></tr>
<tr class="memdesc:gaec88db9c85bfd66909d3172982025862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_DEPTH_WRITEMASK.  <a href="#gaec88db9c85bfd66909d3172982025862">More...</a><br/></td></tr>
<tr class="separator:gaec88db9c85bfd66909d3172982025862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6e75dad01908ff21a473d75483f691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gabc6e75dad01908ff21a473d75483f691">EtatOpenGL::obtenirChaineGlDither</a> () const </td></tr>
<tr class="memdesc:gabc6e75dad01908ff21a473d75483f691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_DITHER.  <a href="#gabc6e75dad01908ff21a473d75483f691">More...</a><br/></td></tr>
<tr class="separator:gabc6e75dad01908ff21a473d75483f691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8239c45bba646389f06a6bdd49670f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae8239c45bba646389f06a6bdd49670f3">EtatOpenGL::obtenirChaineGlDoublebuffer</a> () const </td></tr>
<tr class="memdesc:gae8239c45bba646389f06a6bdd49670f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_DOUBLEBUFFER.  <a href="#gae8239c45bba646389f06a6bdd49670f3">More...</a><br/></td></tr>
<tr class="separator:gae8239c45bba646389f06a6bdd49670f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b705291c7da107645656d5dfb51872a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3b705291c7da107645656d5dfb51872a">EtatOpenGL::obtenirChaineGlDrawBuffer</a> () const </td></tr>
<tr class="memdesc:ga3b705291c7da107645656d5dfb51872a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_DRAW_BUFFER.  <a href="#ga3b705291c7da107645656d5dfb51872a">More...</a><br/></td></tr>
<tr class="separator:ga3b705291c7da107645656d5dfb51872a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982e0dacd18861db40bc153b8e7748d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga982e0dacd18861db40bc153b8e7748d6">EtatOpenGL::obtenirChaineGlEdgeFlag</a> () const </td></tr>
<tr class="memdesc:ga982e0dacd18861db40bc153b8e7748d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_EDGE_FLAG.  <a href="#ga982e0dacd18861db40bc153b8e7748d6">More...</a><br/></td></tr>
<tr class="separator:ga982e0dacd18861db40bc153b8e7748d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac69166db434f3671eb241b00786be34b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac69166db434f3671eb241b00786be34b">EtatOpenGL::obtenirChaineGlEdgeFlagArray</a> () const </td></tr>
<tr class="memdesc:gac69166db434f3671eb241b00786be34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_EDGE_FLAG_ARRAY.  <a href="#gac69166db434f3671eb241b00786be34b">More...</a><br/></td></tr>
<tr class="separator:gac69166db434f3671eb241b00786be34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12932637a943b952d6c822af48b4102a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga12932637a943b952d6c822af48b4102a">EtatOpenGL::obtenirChaineGlEdgeFlagArrayStride</a> () const </td></tr>
<tr class="memdesc:ga12932637a943b952d6c822af48b4102a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_EDGE_FLAG_ARRAY_STRIDE.  <a href="#ga12932637a943b952d6c822af48b4102a">More...</a><br/></td></tr>
<tr class="separator:ga12932637a943b952d6c822af48b4102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ae8d230f1fe733862032e082cfbd2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab0ae8d230f1fe733862032e082cfbd2f">EtatOpenGL::obtenirChaineGlFeedbackBufferSize</a> () const </td></tr>
<tr class="memdesc:gab0ae8d230f1fe733862032e082cfbd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_FEEDBACK_BUFFER_SIZE.  <a href="#gab0ae8d230f1fe733862032e082cfbd2f">More...</a><br/></td></tr>
<tr class="separator:gab0ae8d230f1fe733862032e082cfbd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30bdbc77ee2c0b27ee48e5de2654d29c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga30bdbc77ee2c0b27ee48e5de2654d29c">EtatOpenGL::obtenirChaineGlFeedbackBufferType</a> () const </td></tr>
<tr class="memdesc:ga30bdbc77ee2c0b27ee48e5de2654d29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_FEEDBACK_BUFFER_TYPE.  <a href="#ga30bdbc77ee2c0b27ee48e5de2654d29c">More...</a><br/></td></tr>
<tr class="separator:ga30bdbc77ee2c0b27ee48e5de2654d29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b3d82b8c3940a818e1dab3d69e4899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga73b3d82b8c3940a818e1dab3d69e4899">EtatOpenGL::obtenirChaineGlFog</a> () const </td></tr>
<tr class="memdesc:ga73b3d82b8c3940a818e1dab3d69e4899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_FOG.  <a href="#ga73b3d82b8c3940a818e1dab3d69e4899">More...</a><br/></td></tr>
<tr class="separator:ga73b3d82b8c3940a818e1dab3d69e4899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga572f199118c8cb77085a7eb21f05f7fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga572f199118c8cb77085a7eb21f05f7fb">EtatOpenGL::obtenirChaineGlFogColor</a> () const </td></tr>
<tr class="memdesc:ga572f199118c8cb77085a7eb21f05f7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_FOG_COLOR.  <a href="#ga572f199118c8cb77085a7eb21f05f7fb">More...</a><br/></td></tr>
<tr class="separator:ga572f199118c8cb77085a7eb21f05f7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad8c1de41bc053666ffe001bca8f064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9ad8c1de41bc053666ffe001bca8f064">EtatOpenGL::obtenirChaineGlFogDensity</a> () const </td></tr>
<tr class="memdesc:ga9ad8c1de41bc053666ffe001bca8f064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_FOG_DENSITY.  <a href="#ga9ad8c1de41bc053666ffe001bca8f064">More...</a><br/></td></tr>
<tr class="separator:ga9ad8c1de41bc053666ffe001bca8f064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c6edbc286eed9a47b2e3ed2426e2b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9c6edbc286eed9a47b2e3ed2426e2b92">EtatOpenGL::obtenirChaineGlFogEnd</a> () const </td></tr>
<tr class="memdesc:ga9c6edbc286eed9a47b2e3ed2426e2b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_FOG_END.  <a href="#ga9c6edbc286eed9a47b2e3ed2426e2b92">More...</a><br/></td></tr>
<tr class="separator:ga9c6edbc286eed9a47b2e3ed2426e2b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bd30ecaffe9f7d38e7a447a185dc8d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8bd30ecaffe9f7d38e7a447a185dc8d0">EtatOpenGL::obtenirChaineGlFogHint</a> () const </td></tr>
<tr class="memdesc:ga8bd30ecaffe9f7d38e7a447a185dc8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_FOG_HINT.  <a href="#ga8bd30ecaffe9f7d38e7a447a185dc8d0">More...</a><br/></td></tr>
<tr class="separator:ga8bd30ecaffe9f7d38e7a447a185dc8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929e0d580e014af6abda36f16fce43c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga929e0d580e014af6abda36f16fce43c3">EtatOpenGL::obtenirChaineGlFogIndex</a> () const </td></tr>
<tr class="memdesc:ga929e0d580e014af6abda36f16fce43c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_FOG_INDEX.  <a href="#ga929e0d580e014af6abda36f16fce43c3">More...</a><br/></td></tr>
<tr class="separator:ga929e0d580e014af6abda36f16fce43c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f28b3ec34f9bd4a2080e1252ca64d57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1f28b3ec34f9bd4a2080e1252ca64d57">EtatOpenGL::obtenirChaineGlFogMode</a> () const </td></tr>
<tr class="memdesc:ga1f28b3ec34f9bd4a2080e1252ca64d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_FOG_MODE.  <a href="#ga1f28b3ec34f9bd4a2080e1252ca64d57">More...</a><br/></td></tr>
<tr class="separator:ga1f28b3ec34f9bd4a2080e1252ca64d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7063764912254ec440429aee9e8c3f83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7063764912254ec440429aee9e8c3f83">EtatOpenGL::obtenirChaineGlFogStart</a> () const </td></tr>
<tr class="memdesc:ga7063764912254ec440429aee9e8c3f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_FOG_START.  <a href="#ga7063764912254ec440429aee9e8c3f83">More...</a><br/></td></tr>
<tr class="separator:ga7063764912254ec440429aee9e8c3f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5843f630d530a2112407e19b540e3c42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5843f630d530a2112407e19b540e3c42">EtatOpenGL::obtenirChaineGlFrontFace</a> () const </td></tr>
<tr class="memdesc:ga5843f630d530a2112407e19b540e3c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_FRONT_FACE.  <a href="#ga5843f630d530a2112407e19b540e3c42">More...</a><br/></td></tr>
<tr class="separator:ga5843f630d530a2112407e19b540e3c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb435ce9e5ba38406d8c429a5a0510ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gabb435ce9e5ba38406d8c429a5a0510ed">EtatOpenGL::obtenirChaineGlGreenBias</a> () const </td></tr>
<tr class="memdesc:gabb435ce9e5ba38406d8c429a5a0510ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_GREEN_BIAS.  <a href="#gabb435ce9e5ba38406d8c429a5a0510ed">More...</a><br/></td></tr>
<tr class="separator:gabb435ce9e5ba38406d8c429a5a0510ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga418e82a0a01a9dfe598780e602b41b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga418e82a0a01a9dfe598780e602b41b2f">EtatOpenGL::obtenirChaineGlGreenBits</a> () const </td></tr>
<tr class="memdesc:ga418e82a0a01a9dfe598780e602b41b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_GREEN_BITS.  <a href="#ga418e82a0a01a9dfe598780e602b41b2f">More...</a><br/></td></tr>
<tr class="separator:ga418e82a0a01a9dfe598780e602b41b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga933583938ec361ea302f25dd1323b541"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga933583938ec361ea302f25dd1323b541">EtatOpenGL::obtenirChaineGlGreenScale</a> () const </td></tr>
<tr class="memdesc:ga933583938ec361ea302f25dd1323b541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_GREEN_SCALE.  <a href="#ga933583938ec361ea302f25dd1323b541">More...</a><br/></td></tr>
<tr class="separator:ga933583938ec361ea302f25dd1323b541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a264a046b4714154de9f26b04ab1f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga63a264a046b4714154de9f26b04ab1f8">EtatOpenGL::obtenirChaineGlIndexArray</a> () const </td></tr>
<tr class="memdesc:ga63a264a046b4714154de9f26b04ab1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_INDEX_ARRAY.  <a href="#ga63a264a046b4714154de9f26b04ab1f8">More...</a><br/></td></tr>
<tr class="separator:ga63a264a046b4714154de9f26b04ab1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b9f3969a037a0ed02684b41a8a1328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga79b9f3969a037a0ed02684b41a8a1328">EtatOpenGL::obtenirChaineGlIndexArrayStride</a> () const </td></tr>
<tr class="memdesc:ga79b9f3969a037a0ed02684b41a8a1328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_INDEX_ARRAY_STRIDE.  <a href="#ga79b9f3969a037a0ed02684b41a8a1328">More...</a><br/></td></tr>
<tr class="separator:ga79b9f3969a037a0ed02684b41a8a1328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8479c06a3ede7442505bb38803be818f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8479c06a3ede7442505bb38803be818f">EtatOpenGL::obtenirChaineGlIndexArrayType</a> () const </td></tr>
<tr class="memdesc:ga8479c06a3ede7442505bb38803be818f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_INDEX_ARRAY_TYPE.  <a href="#ga8479c06a3ede7442505bb38803be818f">More...</a><br/></td></tr>
<tr class="separator:ga8479c06a3ede7442505bb38803be818f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae88fc4ca05d447c04f08671823a407a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae88fc4ca05d447c04f08671823a407a3">EtatOpenGL::obtenirChaineGlIndexBits</a> () const </td></tr>
<tr class="memdesc:gae88fc4ca05d447c04f08671823a407a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_INDEX_BITS.  <a href="#gae88fc4ca05d447c04f08671823a407a3">More...</a><br/></td></tr>
<tr class="separator:gae88fc4ca05d447c04f08671823a407a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0d02a72c93d1501432001b500bf6435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad0d02a72c93d1501432001b500bf6435">EtatOpenGL::obtenirChaineGlIndexClearValue</a> () const </td></tr>
<tr class="memdesc:gad0d02a72c93d1501432001b500bf6435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_INDEX_CLEAR_VALUE.  <a href="#gad0d02a72c93d1501432001b500bf6435">More...</a><br/></td></tr>
<tr class="separator:gad0d02a72c93d1501432001b500bf6435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5294ee67327c1a604fe1ac627d539acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5294ee67327c1a604fe1ac627d539acc">EtatOpenGL::obtenirChaineGlIndexLogicOp</a> () const </td></tr>
<tr class="memdesc:ga5294ee67327c1a604fe1ac627d539acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_INDEX_LOGIC_OP.  <a href="#ga5294ee67327c1a604fe1ac627d539acc">More...</a><br/></td></tr>
<tr class="separator:ga5294ee67327c1a604fe1ac627d539acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5413d656a860db0103e85dcd025970e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5413d656a860db0103e85dcd025970e8">EtatOpenGL::obtenirChaineGlIndexMode</a> () const </td></tr>
<tr class="memdesc:ga5413d656a860db0103e85dcd025970e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_INDEX_MODE.  <a href="#ga5413d656a860db0103e85dcd025970e8">More...</a><br/></td></tr>
<tr class="separator:ga5413d656a860db0103e85dcd025970e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ef77a1752dfc7df305e66d9ebc8fee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2ef77a1752dfc7df305e66d9ebc8fee0">EtatOpenGL::obtenirChaineGlIndexOffset</a> () const </td></tr>
<tr class="memdesc:ga2ef77a1752dfc7df305e66d9ebc8fee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_INDEX_OFFSET.  <a href="#ga2ef77a1752dfc7df305e66d9ebc8fee0">More...</a><br/></td></tr>
<tr class="separator:ga2ef77a1752dfc7df305e66d9ebc8fee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb665544045af095c7c301467b71a53d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gabb665544045af095c7c301467b71a53d">EtatOpenGL::obtenirChaineGlIndexShift</a> () const </td></tr>
<tr class="memdesc:gabb665544045af095c7c301467b71a53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_INDEX_SHIFT.  <a href="#gabb665544045af095c7c301467b71a53d">More...</a><br/></td></tr>
<tr class="separator:gabb665544045af095c7c301467b71a53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7041e09cfd847b59e2fd8b306639b2e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7041e09cfd847b59e2fd8b306639b2e2">EtatOpenGL::obtenirChaineGlIndexWritemask</a> () const </td></tr>
<tr class="memdesc:ga7041e09cfd847b59e2fd8b306639b2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_INDEX_WRITEMASK.  <a href="#ga7041e09cfd847b59e2fd8b306639b2e2">More...</a><br/></td></tr>
<tr class="separator:ga7041e09cfd847b59e2fd8b306639b2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373300784f0f42aea9a0d6c78cb01623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga373300784f0f42aea9a0d6c78cb01623">EtatOpenGL::obtenirChaineGlLighti</a> () const </td></tr>
<tr class="memdesc:ga373300784f0f42aea9a0d6c78cb01623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LIGHTi.  <a href="#ga373300784f0f42aea9a0d6c78cb01623">More...</a><br/></td></tr>
<tr class="separator:ga373300784f0f42aea9a0d6c78cb01623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26fe35af4bad0a50b4890f21e61ea02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac26fe35af4bad0a50b4890f21e61ea02">EtatOpenGL::obtenirChaineGlLighting</a> () const </td></tr>
<tr class="memdesc:gac26fe35af4bad0a50b4890f21e61ea02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LIGHTING.  <a href="#gac26fe35af4bad0a50b4890f21e61ea02">More...</a><br/></td></tr>
<tr class="separator:gac26fe35af4bad0a50b4890f21e61ea02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee564b101971fe6c901050b13522dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gafee564b101971fe6c901050b13522dc7">EtatOpenGL::obtenirChaineGlLightModelAmbient</a> () const </td></tr>
<tr class="memdesc:gafee564b101971fe6c901050b13522dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LIGHT_MODEL_AMBIENT.  <a href="#gafee564b101971fe6c901050b13522dc7">More...</a><br/></td></tr>
<tr class="separator:gafee564b101971fe6c901050b13522dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3dbc66405e9f773549840afceebda51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad3dbc66405e9f773549840afceebda51">EtatOpenGL::obtenirChaineGlLightModelLocalViewer</a> () const </td></tr>
<tr class="memdesc:gad3dbc66405e9f773549840afceebda51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LIGHT_MODEL_LOCAL_VIEWER.  <a href="#gad3dbc66405e9f773549840afceebda51">More...</a><br/></td></tr>
<tr class="separator:gad3dbc66405e9f773549840afceebda51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab355049dd400e05dcf9057355f954b2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab355049dd400e05dcf9057355f954b2d">EtatOpenGL::obtenirChaineGlLightModelTwoSide</a> () const </td></tr>
<tr class="memdesc:gab355049dd400e05dcf9057355f954b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LIGHT_MODEL_TWO_SIDE.  <a href="#gab355049dd400e05dcf9057355f954b2d">More...</a><br/></td></tr>
<tr class="separator:gab355049dd400e05dcf9057355f954b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3823c538863f06203e0f72df0af8e517"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3823c538863f06203e0f72df0af8e517">EtatOpenGL::obtenirChaineGlLineSmooth</a> () const </td></tr>
<tr class="memdesc:ga3823c538863f06203e0f72df0af8e517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LINE_SMOOTH.  <a href="#ga3823c538863f06203e0f72df0af8e517">More...</a><br/></td></tr>
<tr class="separator:ga3823c538863f06203e0f72df0af8e517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga259303d6900794169347807035689bc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga259303d6900794169347807035689bc8">EtatOpenGL::obtenirChaineGlLineSmoothHint</a> () const </td></tr>
<tr class="memdesc:ga259303d6900794169347807035689bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LINE_SMOOTH_HINT.  <a href="#ga259303d6900794169347807035689bc8">More...</a><br/></td></tr>
<tr class="separator:ga259303d6900794169347807035689bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6a2fafc56ddcffeb516c7e7451ee620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae6a2fafc56ddcffeb516c7e7451ee620">EtatOpenGL::obtenirChaineGlLineStipple</a> () const </td></tr>
<tr class="memdesc:gae6a2fafc56ddcffeb516c7e7451ee620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LINE_STIPPLE.  <a href="#gae6a2fafc56ddcffeb516c7e7451ee620">More...</a><br/></td></tr>
<tr class="separator:gae6a2fafc56ddcffeb516c7e7451ee620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5594a01ce0e3ce08073c9d8adc2dc7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf5594a01ce0e3ce08073c9d8adc2dc7d">EtatOpenGL::obtenirChaineGlLineStipplePattern</a> () const </td></tr>
<tr class="memdesc:gaf5594a01ce0e3ce08073c9d8adc2dc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LINE_STIPPLE_PATTERN.  <a href="#gaf5594a01ce0e3ce08073c9d8adc2dc7d">More...</a><br/></td></tr>
<tr class="separator:gaf5594a01ce0e3ce08073c9d8adc2dc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b326741292e41732d5e0b646c4f006"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab9b326741292e41732d5e0b646c4f006">EtatOpenGL::obtenirChaineGlLineStippleRepeat</a> () const </td></tr>
<tr class="memdesc:gab9b326741292e41732d5e0b646c4f006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LINE_STIPPLE_REPEAT.  <a href="#gab9b326741292e41732d5e0b646c4f006">More...</a><br/></td></tr>
<tr class="separator:gab9b326741292e41732d5e0b646c4f006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd329652ea9f177db0c0ad44bc9150bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gacd329652ea9f177db0c0ad44bc9150bd">EtatOpenGL::obtenirChaineGlLineWidth</a> () const </td></tr>
<tr class="memdesc:gacd329652ea9f177db0c0ad44bc9150bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LINE_WIDTH.  <a href="#gacd329652ea9f177db0c0ad44bc9150bd">More...</a><br/></td></tr>
<tr class="separator:gacd329652ea9f177db0c0ad44bc9150bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42e5a43f490a0f90bedf54064921de10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga42e5a43f490a0f90bedf54064921de10">EtatOpenGL::obtenirChaineGlLineWidthGranularity</a> () const </td></tr>
<tr class="memdesc:ga42e5a43f490a0f90bedf54064921de10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LINE_WIDTH_GRANULARITY.  <a href="#ga42e5a43f490a0f90bedf54064921de10">More...</a><br/></td></tr>
<tr class="separator:ga42e5a43f490a0f90bedf54064921de10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdf3e63f9464f755958fb682f2a45015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gacdf3e63f9464f755958fb682f2a45015">EtatOpenGL::obtenirChaineGllineWidthRange</a> () const </td></tr>
<tr class="memdesc:gacdf3e63f9464f755958fb682f2a45015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LINE_WIDTH_RANGE.  <a href="#gacdf3e63f9464f755958fb682f2a45015">More...</a><br/></td></tr>
<tr class="separator:gacdf3e63f9464f755958fb682f2a45015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869ac6c34aaec533fb74b4e8095ae993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga869ac6c34aaec533fb74b4e8095ae993">EtatOpenGL::obtenirChaineGlListBase</a> () const </td></tr>
<tr class="memdesc:ga869ac6c34aaec533fb74b4e8095ae993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LIST_BASE.  <a href="#ga869ac6c34aaec533fb74b4e8095ae993">More...</a><br/></td></tr>
<tr class="separator:ga869ac6c34aaec533fb74b4e8095ae993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4486b4e688ef8a216e16b7c1a6ec7a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4486b4e688ef8a216e16b7c1a6ec7a61">EtatOpenGL::obtenirChaineGlListIndex</a> () const </td></tr>
<tr class="memdesc:ga4486b4e688ef8a216e16b7c1a6ec7a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LIST_INDEX.  <a href="#ga4486b4e688ef8a216e16b7c1a6ec7a61">More...</a><br/></td></tr>
<tr class="separator:ga4486b4e688ef8a216e16b7c1a6ec7a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75eb73d049c2865922e414f5a06b749a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga75eb73d049c2865922e414f5a06b749a">EtatOpenGL::obtenirChaineGlListMode</a> () const </td></tr>
<tr class="memdesc:ga75eb73d049c2865922e414f5a06b749a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LIST_MODE.  <a href="#ga75eb73d049c2865922e414f5a06b749a">More...</a><br/></td></tr>
<tr class="separator:ga75eb73d049c2865922e414f5a06b749a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf88292802715427e1a4e58f591b8e67e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf88292802715427e1a4e58f591b8e67e">EtatOpenGL::obtenirChaineGlLogicOpMode</a> () const </td></tr>
<tr class="memdesc:gaf88292802715427e1a4e58f591b8e67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_LOGIC_OP_MODE.  <a href="#gaf88292802715427e1a4e58f591b8e67e">More...</a><br/></td></tr>
<tr class="separator:gaf88292802715427e1a4e58f591b8e67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3e13a4accbc22c40a52ee9cee9fc3e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa3e13a4accbc22c40a52ee9cee9fc3e0">EtatOpenGL::obtenirChaineGlMap1Color4</a> () const </td></tr>
<tr class="memdesc:gaa3e13a4accbc22c40a52ee9cee9fc3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP1_COLOR_4.  <a href="#gaa3e13a4accbc22c40a52ee9cee9fc3e0">More...</a><br/></td></tr>
<tr class="separator:gaa3e13a4accbc22c40a52ee9cee9fc3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad05cd2af4f512deb88aca0b00b0815c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad05cd2af4f512deb88aca0b00b0815c4">EtatOpenGL::obtenirChaineGlMap1GridDomain</a> () const </td></tr>
<tr class="memdesc:gad05cd2af4f512deb88aca0b00b0815c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP1_GRID_DOMAIN.  <a href="#gad05cd2af4f512deb88aca0b00b0815c4">More...</a><br/></td></tr>
<tr class="separator:gad05cd2af4f512deb88aca0b00b0815c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4171a2ed92756d394ed8bae1fc57cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaef4171a2ed92756d394ed8bae1fc57cd">EtatOpenGL::obtenirChaineGlMap1GridSegments</a> () const </td></tr>
<tr class="memdesc:gaef4171a2ed92756d394ed8bae1fc57cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP1_GRID_SEGMENTS.  <a href="#gaef4171a2ed92756d394ed8bae1fc57cd">More...</a><br/></td></tr>
<tr class="separator:gaef4171a2ed92756d394ed8bae1fc57cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ba9a6fe299e4342d28baac6a83c769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga52ba9a6fe299e4342d28baac6a83c769">EtatOpenGL::obtenirChaineGlMap1Index</a> () const </td></tr>
<tr class="memdesc:ga52ba9a6fe299e4342d28baac6a83c769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP1_INDEX.  <a href="#ga52ba9a6fe299e4342d28baac6a83c769">More...</a><br/></td></tr>
<tr class="separator:ga52ba9a6fe299e4342d28baac6a83c769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0e75e07ddc5d51e11b4a9b525ee4190"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad0e75e07ddc5d51e11b4a9b525ee4190">EtatOpenGL::obtenirChaineGlMap1Normal</a> () const </td></tr>
<tr class="memdesc:gad0e75e07ddc5d51e11b4a9b525ee4190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP1_NORMAL.  <a href="#gad0e75e07ddc5d51e11b4a9b525ee4190">More...</a><br/></td></tr>
<tr class="separator:gad0e75e07ddc5d51e11b4a9b525ee4190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06cacbe0ee8f4fe4a6f56571fb8c27c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf06cacbe0ee8f4fe4a6f56571fb8c27c">EtatOpenGL::obtenirChaineGlMap1TextureCoord1</a> () const </td></tr>
<tr class="memdesc:gaf06cacbe0ee8f4fe4a6f56571fb8c27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_1.  <a href="#gaf06cacbe0ee8f4fe4a6f56571fb8c27c">More...</a><br/></td></tr>
<tr class="separator:gaf06cacbe0ee8f4fe4a6f56571fb8c27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade175aafd1123e597959f78fbe04489f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gade175aafd1123e597959f78fbe04489f">EtatOpenGL::obtenirChaineGlMap1TextureCoord2</a> () const </td></tr>
<tr class="memdesc:gade175aafd1123e597959f78fbe04489f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_2.  <a href="#gade175aafd1123e597959f78fbe04489f">More...</a><br/></td></tr>
<tr class="separator:gade175aafd1123e597959f78fbe04489f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6690ab58fbdae84d2543e29cc9e4c41d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6690ab58fbdae84d2543e29cc9e4c41d">EtatOpenGL::obtenirChaineGlMap1TextureCoord3</a> () const </td></tr>
<tr class="memdesc:ga6690ab58fbdae84d2543e29cc9e4c41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_3.  <a href="#ga6690ab58fbdae84d2543e29cc9e4c41d">More...</a><br/></td></tr>
<tr class="separator:ga6690ab58fbdae84d2543e29cc9e4c41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7a65aa462c3a278c42977ed9a35904e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab7a65aa462c3a278c42977ed9a35904e">EtatOpenGL::obtenirChaineGlMap1TextureCoord4</a> () const </td></tr>
<tr class="memdesc:gab7a65aa462c3a278c42977ed9a35904e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_4.  <a href="#gab7a65aa462c3a278c42977ed9a35904e">More...</a><br/></td></tr>
<tr class="separator:gab7a65aa462c3a278c42977ed9a35904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe0e07682a0bb42bb227fecd287de609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gafe0e07682a0bb42bb227fecd287de609">EtatOpenGL::obtenirChaineGlMap1Vertex3</a> () const </td></tr>
<tr class="memdesc:gafe0e07682a0bb42bb227fecd287de609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP1_VERTEX_3.  <a href="#gafe0e07682a0bb42bb227fecd287de609">More...</a><br/></td></tr>
<tr class="separator:gafe0e07682a0bb42bb227fecd287de609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab130a35770d4594bf74a89d18c49697a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab130a35770d4594bf74a89d18c49697a">EtatOpenGL::obtenirChaineGlMap1Vertex4</a> () const </td></tr>
<tr class="memdesc:gab130a35770d4594bf74a89d18c49697a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP1_VERTEX_4.  <a href="#gab130a35770d4594bf74a89d18c49697a">More...</a><br/></td></tr>
<tr class="separator:gab130a35770d4594bf74a89d18c49697a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85dca50f7d25944ca4158173a630d15d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga85dca50f7d25944ca4158173a630d15d">EtatOpenGL::obtenirChaineGlMap2Color4</a> () const </td></tr>
<tr class="memdesc:ga85dca50f7d25944ca4158173a630d15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP2_COLOR_4.  <a href="#ga85dca50f7d25944ca4158173a630d15d">More...</a><br/></td></tr>
<tr class="separator:ga85dca50f7d25944ca4158173a630d15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15f308a3995cd63e0bf8ff13fd1024dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga15f308a3995cd63e0bf8ff13fd1024dd">EtatOpenGL::obtenirChaineGlMap2GridDomain</a> () const </td></tr>
<tr class="memdesc:ga15f308a3995cd63e0bf8ff13fd1024dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP2_GRID_DOMAIN.  <a href="#ga15f308a3995cd63e0bf8ff13fd1024dd">More...</a><br/></td></tr>
<tr class="separator:ga15f308a3995cd63e0bf8ff13fd1024dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc72b6b6d1f670c6bb2a37bb02f22cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7cc72b6b6d1f670c6bb2a37bb02f22cc">EtatOpenGL::obtenirChaineGlMap2GridSegments</a> () const </td></tr>
<tr class="memdesc:ga7cc72b6b6d1f670c6bb2a37bb02f22cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP2_GRID_SEGMENTS.  <a href="#ga7cc72b6b6d1f670c6bb2a37bb02f22cc">More...</a><br/></td></tr>
<tr class="separator:ga7cc72b6b6d1f670c6bb2a37bb02f22cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c26c0fce87b7c852f2819ddbc816835"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5c26c0fce87b7c852f2819ddbc816835">EtatOpenGL::obtenirChaineGlMap2Index</a> () const </td></tr>
<tr class="memdesc:ga5c26c0fce87b7c852f2819ddbc816835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP2_INDEX.  <a href="#ga5c26c0fce87b7c852f2819ddbc816835">More...</a><br/></td></tr>
<tr class="separator:ga5c26c0fce87b7c852f2819ddbc816835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga281e64b376bb0c3f7f7090820a64bd7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga281e64b376bb0c3f7f7090820a64bd7e">EtatOpenGL::obtenirChaineGlMap2Normal</a> () const </td></tr>
<tr class="memdesc:ga281e64b376bb0c3f7f7090820a64bd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP2_NORMAL.  <a href="#ga281e64b376bb0c3f7f7090820a64bd7e">More...</a><br/></td></tr>
<tr class="separator:ga281e64b376bb0c3f7f7090820a64bd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb7c67ea193286a4088b9dcc172abef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gadb7c67ea193286a4088b9dcc172abef6">EtatOpenGL::obtenirChaineGlMap2TextureCoord1</a> () const </td></tr>
<tr class="memdesc:gadb7c67ea193286a4088b9dcc172abef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_1.  <a href="#gadb7c67ea193286a4088b9dcc172abef6">More...</a><br/></td></tr>
<tr class="separator:gadb7c67ea193286a4088b9dcc172abef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5cb23274f1ad4c504c5aed7947a3432"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf5cb23274f1ad4c504c5aed7947a3432">EtatOpenGL::obtenirChaineGlMap2TextureCoord2</a> () const </td></tr>
<tr class="memdesc:gaf5cb23274f1ad4c504c5aed7947a3432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_2.  <a href="#gaf5cb23274f1ad4c504c5aed7947a3432">More...</a><br/></td></tr>
<tr class="separator:gaf5cb23274f1ad4c504c5aed7947a3432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4b636ae980e2c420c9a7357fe8d58cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad4b636ae980e2c420c9a7357fe8d58cc">EtatOpenGL::obtenirChaineGlMap2TextureCoord3</a> () const </td></tr>
<tr class="memdesc:gad4b636ae980e2c420c9a7357fe8d58cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_3.  <a href="#gad4b636ae980e2c420c9a7357fe8d58cc">More...</a><br/></td></tr>
<tr class="separator:gad4b636ae980e2c420c9a7357fe8d58cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0716a8c85e544f43620ea6664c58b570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga0716a8c85e544f43620ea6664c58b570">EtatOpenGL::obtenirChaineGlMap2TextureCoord4</a> () const </td></tr>
<tr class="memdesc:ga0716a8c85e544f43620ea6664c58b570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_4.  <a href="#ga0716a8c85e544f43620ea6664c58b570">More...</a><br/></td></tr>
<tr class="separator:ga0716a8c85e544f43620ea6664c58b570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d031ab910660e0f56b3ed4a95d2bfc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7d031ab910660e0f56b3ed4a95d2bfc6">EtatOpenGL::obtenirChaineGlMap2Vertex3</a> () const </td></tr>
<tr class="memdesc:ga7d031ab910660e0f56b3ed4a95d2bfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP2_VERTEX_3.  <a href="#ga7d031ab910660e0f56b3ed4a95d2bfc6">More...</a><br/></td></tr>
<tr class="separator:ga7d031ab910660e0f56b3ed4a95d2bfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga866e31b0b0469c11f0c0bee0bb4f9973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga866e31b0b0469c11f0c0bee0bb4f9973">EtatOpenGL::obtenirChaineGlMap2Vertex4</a> () const </td></tr>
<tr class="memdesc:ga866e31b0b0469c11f0c0bee0bb4f9973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP2_VERTEX_4.  <a href="#ga866e31b0b0469c11f0c0bee0bb4f9973">More...</a><br/></td></tr>
<tr class="separator:ga866e31b0b0469c11f0c0bee0bb4f9973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7224b43655a9b3d8a381bea11d42d401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7224b43655a9b3d8a381bea11d42d401">EtatOpenGL::obtenirChaineGlMapColor</a> () const </td></tr>
<tr class="memdesc:ga7224b43655a9b3d8a381bea11d42d401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP_COLOR.  <a href="#ga7224b43655a9b3d8a381bea11d42d401">More...</a><br/></td></tr>
<tr class="separator:ga7224b43655a9b3d8a381bea11d42d401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17a6e4887be554b1845d8eb595129b0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga17a6e4887be554b1845d8eb595129b0c">EtatOpenGL::obtenirChaineGlMapStencil</a> () const </td></tr>
<tr class="memdesc:ga17a6e4887be554b1845d8eb595129b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAP_STENCIL.  <a href="#ga17a6e4887be554b1845d8eb595129b0c">More...</a><br/></td></tr>
<tr class="separator:ga17a6e4887be554b1845d8eb595129b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb5f2ef622bebc2786449eda2460d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3cb5f2ef622bebc2786449eda2460d55">EtatOpenGL::obtenirChaineGlMatrixMode</a> () const </td></tr>
<tr class="memdesc:ga3cb5f2ef622bebc2786449eda2460d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MATRIX_MODE.  <a href="#ga3cb5f2ef622bebc2786449eda2460d55">More...</a><br/></td></tr>
<tr class="separator:ga3cb5f2ef622bebc2786449eda2460d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2085416ccd06cb60bc98ba2207174dd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2085416ccd06cb60bc98ba2207174dd1">EtatOpenGL::obtenirChaineGlMaxClientAttribStackDepth</a> () const </td></tr>
<tr class="memdesc:ga2085416ccd06cb60bc98ba2207174dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_CLIENT_ATTRIB_STACK_DEPTH.  <a href="#ga2085416ccd06cb60bc98ba2207174dd1">More...</a><br/></td></tr>
<tr class="separator:ga2085416ccd06cb60bc98ba2207174dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03eca9a37a755a11183714292f89779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa03eca9a37a755a11183714292f89779">EtatOpenGL::obtenirChaineGlMaxAttribStackDepth</a> () const </td></tr>
<tr class="memdesc:gaa03eca9a37a755a11183714292f89779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_ATTRIB_STACK_DEPTH.  <a href="#gaa03eca9a37a755a11183714292f89779">More...</a><br/></td></tr>
<tr class="separator:gaa03eca9a37a755a11183714292f89779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae90d5285df064d711bedd09091ba413b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae90d5285df064d711bedd09091ba413b">EtatOpenGL::obtenirChaineGlMaxClipPlanes</a> () const </td></tr>
<tr class="memdesc:gae90d5285df064d711bedd09091ba413b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_CLIP_PLANES.  <a href="#gae90d5285df064d711bedd09091ba413b">More...</a><br/></td></tr>
<tr class="separator:gae90d5285df064d711bedd09091ba413b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf82e6892182ffe565a05329073a06248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf82e6892182ffe565a05329073a06248">EtatOpenGL::obtenirChaineGlMaxEvalOrder</a> () const </td></tr>
<tr class="memdesc:gaf82e6892182ffe565a05329073a06248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_EVAL_ORDER.  <a href="#gaf82e6892182ffe565a05329073a06248">More...</a><br/></td></tr>
<tr class="separator:gaf82e6892182ffe565a05329073a06248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95b23ba66220abe4def913fd80f31f9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga95b23ba66220abe4def913fd80f31f9c">EtatOpenGL::obtenirChaineGlMaxLights</a> () const </td></tr>
<tr class="memdesc:ga95b23ba66220abe4def913fd80f31f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_LIGHTS.  <a href="#ga95b23ba66220abe4def913fd80f31f9c">More...</a><br/></td></tr>
<tr class="separator:ga95b23ba66220abe4def913fd80f31f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab626bdfc4cf8d6445955270799c969a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaab626bdfc4cf8d6445955270799c969a">EtatOpenGL::obtenirChaineGlMaxListNesting</a> () const </td></tr>
<tr class="memdesc:gaab626bdfc4cf8d6445955270799c969a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_LIST_NESTING.  <a href="#gaab626bdfc4cf8d6445955270799c969a">More...</a><br/></td></tr>
<tr class="separator:gaab626bdfc4cf8d6445955270799c969a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7a64fd525a66dfc542f8d38470e6df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7a7a64fd525a66dfc542f8d38470e6df">EtatOpenGL::obtenirChaineGlMaxModelviewStackDepth</a> () const </td></tr>
<tr class="memdesc:ga7a7a64fd525a66dfc542f8d38470e6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_MODELVIEW_STACK_DEPTH.  <a href="#ga7a7a64fd525a66dfc542f8d38470e6df">More...</a><br/></td></tr>
<tr class="separator:ga7a7a64fd525a66dfc542f8d38470e6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad22c079b7e29e5cfb6ee2fe9bb220816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad22c079b7e29e5cfb6ee2fe9bb220816">EtatOpenGL::obtenirChaineGlMaxNameStackDepth</a> () const </td></tr>
<tr class="memdesc:gad22c079b7e29e5cfb6ee2fe9bb220816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_NAME_STACK_DEPTH.  <a href="#gad22c079b7e29e5cfb6ee2fe9bb220816">More...</a><br/></td></tr>
<tr class="separator:gad22c079b7e29e5cfb6ee2fe9bb220816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga266533ff4a35f65c19be95594d07f435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga266533ff4a35f65c19be95594d07f435">EtatOpenGL::obtenirChaineGlMaxPixelMapTable</a> () const </td></tr>
<tr class="memdesc:ga266533ff4a35f65c19be95594d07f435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_PIXEL_MAP_TABLE.  <a href="#ga266533ff4a35f65c19be95594d07f435">More...</a><br/></td></tr>
<tr class="separator:ga266533ff4a35f65c19be95594d07f435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2d3530aa09867d9c01d8433839011e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8c2d3530aa09867d9c01d8433839011e">EtatOpenGL::obtenirChaineGlMaxProjectionStackDepth</a> () const </td></tr>
<tr class="memdesc:ga8c2d3530aa09867d9c01d8433839011e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_PROJECTION_STACK_DEPTH.  <a href="#ga8c2d3530aa09867d9c01d8433839011e">More...</a><br/></td></tr>
<tr class="separator:ga8c2d3530aa09867d9c01d8433839011e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba7eaad6682c2c4aa8925501601c606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaeba7eaad6682c2c4aa8925501601c606">EtatOpenGL::obtenirChaineGlMaxTextureSize</a> () const </td></tr>
<tr class="memdesc:gaeba7eaad6682c2c4aa8925501601c606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_TEXTURE_SIZE.  <a href="#gaeba7eaad6682c2c4aa8925501601c606">More...</a><br/></td></tr>
<tr class="separator:gaeba7eaad6682c2c4aa8925501601c606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aac1a0891487831a30125fca75bec93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9aac1a0891487831a30125fca75bec93">EtatOpenGL::obtenirChaineGlMaxTextureStackDepth</a> () const </td></tr>
<tr class="memdesc:ga9aac1a0891487831a30125fca75bec93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_TEXTURE_STACK_DEPTH.  <a href="#ga9aac1a0891487831a30125fca75bec93">More...</a><br/></td></tr>
<tr class="separator:ga9aac1a0891487831a30125fca75bec93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dad12ef08cd32b9fb94e214f00a95a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga0dad12ef08cd32b9fb94e214f00a95a9">EtatOpenGL::obtenirChaineGlMaxViewportDims</a> () const </td></tr>
<tr class="memdesc:ga0dad12ef08cd32b9fb94e214f00a95a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MAX_VIEWPORT_DIMS.  <a href="#ga0dad12ef08cd32b9fb94e214f00a95a9">More...</a><br/></td></tr>
<tr class="separator:ga0dad12ef08cd32b9fb94e214f00a95a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c62c93a914527f821b2aef913fada7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga44c62c93a914527f821b2aef913fada7">EtatOpenGL::obtenirChaineGlModelviewMatrix</a> () const </td></tr>
<tr class="memdesc:ga44c62c93a914527f821b2aef913fada7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MODELVIEW_MATRIX.  <a href="#ga44c62c93a914527f821b2aef913fada7">More...</a><br/></td></tr>
<tr class="separator:ga44c62c93a914527f821b2aef913fada7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga745672a8704edbf33daef5314f9cdfaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga745672a8704edbf33daef5314f9cdfaf">EtatOpenGL::obtenirChaineGlModelviewStackDepth</a> () const </td></tr>
<tr class="memdesc:ga745672a8704edbf33daef5314f9cdfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_MODELVIEW_STACK_DEPTH.  <a href="#ga745672a8704edbf33daef5314f9cdfaf">More...</a><br/></td></tr>
<tr class="separator:ga745672a8704edbf33daef5314f9cdfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04c7aa5d2e684fa0029e53b8c3b2cda8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga04c7aa5d2e684fa0029e53b8c3b2cda8">EtatOpenGL::obtenirChaineGlNameStackDepth</a> () const </td></tr>
<tr class="memdesc:ga04c7aa5d2e684fa0029e53b8c3b2cda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_NAME_STACK_DEPTH.  <a href="#ga04c7aa5d2e684fa0029e53b8c3b2cda8">More...</a><br/></td></tr>
<tr class="separator:ga04c7aa5d2e684fa0029e53b8c3b2cda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa71b4ce64f1a5f86f8822904e51b549f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa71b4ce64f1a5f86f8822904e51b549f">EtatOpenGL::obtenirChaineGlNormalArray</a> () const </td></tr>
<tr class="memdesc:gaa71b4ce64f1a5f86f8822904e51b549f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_NORMAL_ARRAY.  <a href="#gaa71b4ce64f1a5f86f8822904e51b549f">More...</a><br/></td></tr>
<tr class="separator:gaa71b4ce64f1a5f86f8822904e51b549f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9388bcac733bb55d8bff349828b9d86d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9388bcac733bb55d8bff349828b9d86d">EtatOpenGL::obtenirChaineGlNormalArrayStride</a> () const </td></tr>
<tr class="memdesc:ga9388bcac733bb55d8bff349828b9d86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_NORMAL_ARRAY_STRIDE.  <a href="#ga9388bcac733bb55d8bff349828b9d86d">More...</a><br/></td></tr>
<tr class="separator:ga9388bcac733bb55d8bff349828b9d86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2ac905eb6421d2ff8edb736557f40e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac2ac905eb6421d2ff8edb736557f40e5">EtatOpenGL::obtenirChaineGlNormalArrayType</a> () const </td></tr>
<tr class="memdesc:gac2ac905eb6421d2ff8edb736557f40e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_NORMAL_ARRAY_TYPE.  <a href="#gac2ac905eb6421d2ff8edb736557f40e5">More...</a><br/></td></tr>
<tr class="separator:gac2ac905eb6421d2ff8edb736557f40e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f8c7f8e749817f94751308b2344af4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab8f8c7f8e749817f94751308b2344af4">EtatOpenGL::obtenirChaineGlNormalize</a> () const </td></tr>
<tr class="memdesc:gab8f8c7f8e749817f94751308b2344af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_NORMALIZE.  <a href="#gab8f8c7f8e749817f94751308b2344af4">More...</a><br/></td></tr>
<tr class="separator:gab8f8c7f8e749817f94751308b2344af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b46757dfa6068f0833baab8d98d2c2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7b46757dfa6068f0833baab8d98d2c2a">EtatOpenGL::obtenirChaineGlPackAlignment</a> () const </td></tr>
<tr class="memdesc:ga7b46757dfa6068f0833baab8d98d2c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PACK_ALIGNMENT.  <a href="#ga7b46757dfa6068f0833baab8d98d2c2a">More...</a><br/></td></tr>
<tr class="separator:ga7b46757dfa6068f0833baab8d98d2c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49cc9b47a26f144e0651b4679752a02c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga49cc9b47a26f144e0651b4679752a02c">EtatOpenGL::obtenirChaineGlPackLsbFirst</a> () const </td></tr>
<tr class="memdesc:ga49cc9b47a26f144e0651b4679752a02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PACK_LSB_FIRST.  <a href="#ga49cc9b47a26f144e0651b4679752a02c">More...</a><br/></td></tr>
<tr class="separator:ga49cc9b47a26f144e0651b4679752a02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64b0337d0f84557f6f8661ec6e03e154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga64b0337d0f84557f6f8661ec6e03e154">EtatOpenGL::obtenirChaineGlPackRowLength</a> () const </td></tr>
<tr class="memdesc:ga64b0337d0f84557f6f8661ec6e03e154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PACK_ROW_LENGTH.  <a href="#ga64b0337d0f84557f6f8661ec6e03e154">More...</a><br/></td></tr>
<tr class="separator:ga64b0337d0f84557f6f8661ec6e03e154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb44f6347d29047a0a3789c51f4913f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gadb44f6347d29047a0a3789c51f4913f6">EtatOpenGL::obtenirChaineGlPackSkipPixels</a> () const </td></tr>
<tr class="memdesc:gadb44f6347d29047a0a3789c51f4913f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PACK_SKIP_PIXELS.  <a href="#gadb44f6347d29047a0a3789c51f4913f6">More...</a><br/></td></tr>
<tr class="separator:gadb44f6347d29047a0a3789c51f4913f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13b70d48642c0b921c0497f1ed7e88fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga13b70d48642c0b921c0497f1ed7e88fa">EtatOpenGL::obtenirChaineGlPackSkipRows</a> () const </td></tr>
<tr class="memdesc:ga13b70d48642c0b921c0497f1ed7e88fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PACK_SKIP_ROWS.  <a href="#ga13b70d48642c0b921c0497f1ed7e88fa">More...</a><br/></td></tr>
<tr class="separator:ga13b70d48642c0b921c0497f1ed7e88fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34c8e9bce5b0b759995934900bc33e14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga34c8e9bce5b0b759995934900bc33e14">EtatOpenGL::obtenirChaineGlPackSwapBytes</a> () const </td></tr>
<tr class="memdesc:ga34c8e9bce5b0b759995934900bc33e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PACK_SWAP_BYTES.  <a href="#ga34c8e9bce5b0b759995934900bc33e14">More...</a><br/></td></tr>
<tr class="separator:ga34c8e9bce5b0b759995934900bc33e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f8a371d540a654c038ff2e3301a63d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2f8a371d540a654c038ff2e3301a63d3">EtatOpenGL::obtenirChaineGlPerspectiveCorrectionHint</a> () const </td></tr>
<tr class="memdesc:ga2f8a371d540a654c038ff2e3301a63d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PERSPECTIVE_CORRECTION_HINT.  <a href="#ga2f8a371d540a654c038ff2e3301a63d3">More...</a><br/></td></tr>
<tr class="separator:ga2f8a371d540a654c038ff2e3301a63d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d92a97f95de6e5eb298d27c342a4375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6d92a97f95de6e5eb298d27c342a4375">EtatOpenGL::obtenirChaineGlPixelMapAToASize</a> () const </td></tr>
<tr class="memdesc:ga6d92a97f95de6e5eb298d27c342a4375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PIXEL_MAP_A_TO_A_SIZE.  <a href="#ga6d92a97f95de6e5eb298d27c342a4375">More...</a><br/></td></tr>
<tr class="separator:ga6d92a97f95de6e5eb298d27c342a4375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga554e72e1ef666b6dca527a1073219c9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga554e72e1ef666b6dca527a1073219c9e">EtatOpenGL::obtenirChaineGlPixelMapBToBSize</a> () const </td></tr>
<tr class="memdesc:ga554e72e1ef666b6dca527a1073219c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PIXEL_MAP_B_TO_B_SIZE.  <a href="#ga554e72e1ef666b6dca527a1073219c9e">More...</a><br/></td></tr>
<tr class="separator:ga554e72e1ef666b6dca527a1073219c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad80ac227ca04522df384be1e0f93b546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad80ac227ca04522df384be1e0f93b546">EtatOpenGL::obtenirChaineGlPixelMapGToGSize</a> () const </td></tr>
<tr class="memdesc:gad80ac227ca04522df384be1e0f93b546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PIXEL_MAP_G_TO_G_SIZE.  <a href="#gad80ac227ca04522df384be1e0f93b546">More...</a><br/></td></tr>
<tr class="separator:gad80ac227ca04522df384be1e0f93b546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadb89e110f09aaf815829f028ab539d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gadadb89e110f09aaf815829f028ab539d">EtatOpenGL::obtenirChaineGlPixelMapIToASize</a> () const </td></tr>
<tr class="memdesc:gadadb89e110f09aaf815829f028ab539d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_A_SIZE.  <a href="#gadadb89e110f09aaf815829f028ab539d">More...</a><br/></td></tr>
<tr class="separator:gadadb89e110f09aaf815829f028ab539d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fac55d9d77a0b119c7247536471b5fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8fac55d9d77a0b119c7247536471b5fe">EtatOpenGL::obtenirChaineGlPixelMapIToBSize</a> () const </td></tr>
<tr class="memdesc:ga8fac55d9d77a0b119c7247536471b5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_B_SIZE.  <a href="#ga8fac55d9d77a0b119c7247536471b5fe">More...</a><br/></td></tr>
<tr class="separator:ga8fac55d9d77a0b119c7247536471b5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa449af86fad19dad37eea16a918b3c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa449af86fad19dad37eea16a918b3c33">EtatOpenGL::obtenirChaineGlPixelMapIToGSize</a> () const </td></tr>
<tr class="memdesc:gaa449af86fad19dad37eea16a918b3c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_G_SIZE.  <a href="#gaa449af86fad19dad37eea16a918b3c33">More...</a><br/></td></tr>
<tr class="separator:gaa449af86fad19dad37eea16a918b3c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb7b39aef0ca240d98e9507703cd1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga0eb7b39aef0ca240d98e9507703cd1e4">EtatOpenGL::obtenirChaineGlPixelMapIToISize</a> () const </td></tr>
<tr class="memdesc:ga0eb7b39aef0ca240d98e9507703cd1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_I_SIZE.  <a href="#ga0eb7b39aef0ca240d98e9507703cd1e4">More...</a><br/></td></tr>
<tr class="separator:ga0eb7b39aef0ca240d98e9507703cd1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cc6e9acee4df62ca1407e6b42d87d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad3cc6e9acee4df62ca1407e6b42d87d4">EtatOpenGL::obtenirChaineGlPixelMapIToRSize</a> () const </td></tr>
<tr class="memdesc:gad3cc6e9acee4df62ca1407e6b42d87d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_R_SIZE.  <a href="#gad3cc6e9acee4df62ca1407e6b42d87d4">More...</a><br/></td></tr>
<tr class="separator:gad3cc6e9acee4df62ca1407e6b42d87d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315fd9fa34e26c259ce76e33ddadc11b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga315fd9fa34e26c259ce76e33ddadc11b">EtatOpenGL::obtenirChaineGlPixelMapRToRSize</a> () const </td></tr>
<tr class="memdesc:ga315fd9fa34e26c259ce76e33ddadc11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PIXEL_MAP_R_TO_R_SIZE.  <a href="#ga315fd9fa34e26c259ce76e33ddadc11b">More...</a><br/></td></tr>
<tr class="separator:ga315fd9fa34e26c259ce76e33ddadc11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d77ae2d820ab8304af841033ee957ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5d77ae2d820ab8304af841033ee957ef">EtatOpenGL::obtenirChaineGlPixelMapSToSSize</a> () const </td></tr>
<tr class="memdesc:ga5d77ae2d820ab8304af841033ee957ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PIXEL_MAP_S_TO_S_SIZE.  <a href="#ga5d77ae2d820ab8304af841033ee957ef">More...</a><br/></td></tr>
<tr class="separator:ga5d77ae2d820ab8304af841033ee957ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02efc6cfc989e454b9cc91443fef303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad02efc6cfc989e454b9cc91443fef303">EtatOpenGL::obtenirChaineGlPointSize</a> () const </td></tr>
<tr class="memdesc:gad02efc6cfc989e454b9cc91443fef303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POINT_SIZE.  <a href="#gad02efc6cfc989e454b9cc91443fef303">More...</a><br/></td></tr>
<tr class="separator:gad02efc6cfc989e454b9cc91443fef303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77ea6a1da567197d644dcd11743f67a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga77ea6a1da567197d644dcd11743f67a8">EtatOpenGL::obtenirChaineGlPointSizeGranularity</a> () const </td></tr>
<tr class="memdesc:ga77ea6a1da567197d644dcd11743f67a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POINT_SIZE_GRANULARITY.  <a href="#ga77ea6a1da567197d644dcd11743f67a8">More...</a><br/></td></tr>
<tr class="separator:ga77ea6a1da567197d644dcd11743f67a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2553c47e6d7fa315b61ab5dcdb1506e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab2553c47e6d7fa315b61ab5dcdb1506e">EtatOpenGL::obtenirChaineGlPointSizeRange</a> () const </td></tr>
<tr class="memdesc:gab2553c47e6d7fa315b61ab5dcdb1506e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POINT_SIZE_RANGE.  <a href="#gab2553c47e6d7fa315b61ab5dcdb1506e">More...</a><br/></td></tr>
<tr class="separator:gab2553c47e6d7fa315b61ab5dcdb1506e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32e178d5d54d00dc20f27cf516943a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga32e178d5d54d00dc20f27cf516943a65">EtatOpenGL::obtenirChaineGlPointSmooth</a> () const </td></tr>
<tr class="memdesc:ga32e178d5d54d00dc20f27cf516943a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POINT_SMOOTH.  <a href="#ga32e178d5d54d00dc20f27cf516943a65">More...</a><br/></td></tr>
<tr class="separator:ga32e178d5d54d00dc20f27cf516943a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9c02409795d34b851b6da29f7f91c35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa9c02409795d34b851b6da29f7f91c35">EtatOpenGL::obtenirChaineGlPointSmoothHint</a> () const </td></tr>
<tr class="memdesc:gaa9c02409795d34b851b6da29f7f91c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POINT_SMOOTH_HINT.  <a href="#gaa9c02409795d34b851b6da29f7f91c35">More...</a><br/></td></tr>
<tr class="separator:gaa9c02409795d34b851b6da29f7f91c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799784d6a719eb2c25ffd5854ec09aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga799784d6a719eb2c25ffd5854ec09aa8">EtatOpenGL::obtenirChaineGlPolygonMode</a> () const </td></tr>
<tr class="memdesc:ga799784d6a719eb2c25ffd5854ec09aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POLYGON_MODE.  <a href="#ga799784d6a719eb2c25ffd5854ec09aa8">More...</a><br/></td></tr>
<tr class="separator:ga799784d6a719eb2c25ffd5854ec09aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc33f5a28be70057bb4b6124b67955a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaedc33f5a28be70057bb4b6124b67955a">EtatOpenGL::obtenirChaineGlPolygonOffsetFactor</a> () const </td></tr>
<tr class="memdesc:gaedc33f5a28be70057bb4b6124b67955a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_FACTOR.  <a href="#gaedc33f5a28be70057bb4b6124b67955a">More...</a><br/></td></tr>
<tr class="separator:gaedc33f5a28be70057bb4b6124b67955a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5f7eacf5333293ba0f1a02bbe3cdc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5e5f7eacf5333293ba0f1a02bbe3cdc5">EtatOpenGL::obtenirChaineGlPolygonOffsetUnits</a> () const </td></tr>
<tr class="memdesc:ga5e5f7eacf5333293ba0f1a02bbe3cdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_UNITS.  <a href="#ga5e5f7eacf5333293ba0f1a02bbe3cdc5">More...</a><br/></td></tr>
<tr class="separator:ga5e5f7eacf5333293ba0f1a02bbe3cdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f958b650aeedc92140b1406f98d985"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa4f958b650aeedc92140b1406f98d985">EtatOpenGL::obtenirChaineGlPolygonOffsetFill</a> () const </td></tr>
<tr class="memdesc:gaa4f958b650aeedc92140b1406f98d985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_FILL.  <a href="#gaa4f958b650aeedc92140b1406f98d985">More...</a><br/></td></tr>
<tr class="separator:gaa4f958b650aeedc92140b1406f98d985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7470a404bbcbef21d1316b3bfd02deb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7470a404bbcbef21d1316b3bfd02deb6">EtatOpenGL::obtenirChaineGlPolygonOffsetLine</a> () const </td></tr>
<tr class="memdesc:ga7470a404bbcbef21d1316b3bfd02deb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_LINE.  <a href="#ga7470a404bbcbef21d1316b3bfd02deb6">More...</a><br/></td></tr>
<tr class="separator:ga7470a404bbcbef21d1316b3bfd02deb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19543110e1a7115a1ec9a30caaa490fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga19543110e1a7115a1ec9a30caaa490fe">EtatOpenGL::obtenirChaineGlPolygonOffsetPoint</a> () const </td></tr>
<tr class="memdesc:ga19543110e1a7115a1ec9a30caaa490fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_POINT.  <a href="#ga19543110e1a7115a1ec9a30caaa490fe">More...</a><br/></td></tr>
<tr class="separator:ga19543110e1a7115a1ec9a30caaa490fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4627c5f84f92d1e259d756aba7d6068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac4627c5f84f92d1e259d756aba7d6068">EtatOpenGL::obtenirChaineGlPolygonSmooth</a> () const </td></tr>
<tr class="memdesc:gac4627c5f84f92d1e259d756aba7d6068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POLYGON_SMOOTH.  <a href="#gac4627c5f84f92d1e259d756aba7d6068">More...</a><br/></td></tr>
<tr class="separator:gac4627c5f84f92d1e259d756aba7d6068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45100a9646aab1c37b538298c55cb0ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga45100a9646aab1c37b538298c55cb0ca">EtatOpenGL::obtenirChaineGlPolygonSmoothHint</a> () const </td></tr>
<tr class="memdesc:ga45100a9646aab1c37b538298c55cb0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POLYGON_SMOOTH_HINT.  <a href="#ga45100a9646aab1c37b538298c55cb0ca">More...</a><br/></td></tr>
<tr class="separator:ga45100a9646aab1c37b538298c55cb0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53fd366a5e9d6eef773c883b1d2914d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga53fd366a5e9d6eef773c883b1d2914d5">EtatOpenGL::obtenirChaineGlPolygonStipple</a> () const </td></tr>
<tr class="memdesc:ga53fd366a5e9d6eef773c883b1d2914d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_POLYGON_STIPPLE.  <a href="#ga53fd366a5e9d6eef773c883b1d2914d5">More...</a><br/></td></tr>
<tr class="separator:ga53fd366a5e9d6eef773c883b1d2914d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e56c1c62378ae9385db874bf2b6a030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4e56c1c62378ae9385db874bf2b6a030">EtatOpenGL::obtenirChaineGlProjectionMatrix</a> () const </td></tr>
<tr class="memdesc:ga4e56c1c62378ae9385db874bf2b6a030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PROJECTION_MATRIX.  <a href="#ga4e56c1c62378ae9385db874bf2b6a030">More...</a><br/></td></tr>
<tr class="separator:ga4e56c1c62378ae9385db874bf2b6a030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d5e19c001663ff2943c43cc9b0c0ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad2d5e19c001663ff2943c43cc9b0c0ea">EtatOpenGL::obtenirChaineGlProjectionStackDepth</a> () const </td></tr>
<tr class="memdesc:gad2d5e19c001663ff2943c43cc9b0c0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_PROJECTION_STACK_DEPTH.  <a href="#gad2d5e19c001663ff2943c43cc9b0c0ea">More...</a><br/></td></tr>
<tr class="separator:gad2d5e19c001663ff2943c43cc9b0c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3a759c6f7b623d7598708ca4810b00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5d3a759c6f7b623d7598708ca4810b00">EtatOpenGL::obtenirChaineGlReadBuffer</a> () const </td></tr>
<tr class="memdesc:ga5d3a759c6f7b623d7598708ca4810b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_READ_BUFFER.  <a href="#ga5d3a759c6f7b623d7598708ca4810b00">More...</a><br/></td></tr>
<tr class="separator:ga5d3a759c6f7b623d7598708ca4810b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db73eaaf942ff5c5aa9b62e0386f9a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4db73eaaf942ff5c5aa9b62e0386f9a9">EtatOpenGL::obtenirChaineGlRedBias</a> () const </td></tr>
<tr class="memdesc:ga4db73eaaf942ff5c5aa9b62e0386f9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_RED_BIAS.  <a href="#ga4db73eaaf942ff5c5aa9b62e0386f9a9">More...</a><br/></td></tr>
<tr class="separator:ga4db73eaaf942ff5c5aa9b62e0386f9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4060a4139d031b9f8b9b1198c4a89f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac4060a4139d031b9f8b9b1198c4a89f5">EtatOpenGL::obtenirChaineGlRedBits</a> () const </td></tr>
<tr class="memdesc:gac4060a4139d031b9f8b9b1198c4a89f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_RED_BITS.  <a href="#gac4060a4139d031b9f8b9b1198c4a89f5">More...</a><br/></td></tr>
<tr class="separator:gac4060a4139d031b9f8b9b1198c4a89f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae20713f3668cb6be662849b8de30d623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae20713f3668cb6be662849b8de30d623">EtatOpenGL::obtenirChaineGlRedScale</a> () const </td></tr>
<tr class="memdesc:gae20713f3668cb6be662849b8de30d623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_RED_SCALE.  <a href="#gae20713f3668cb6be662849b8de30d623">More...</a><br/></td></tr>
<tr class="separator:gae20713f3668cb6be662849b8de30d623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64d9bf10216007aeb301d43ac14f82b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga64d9bf10216007aeb301d43ac14f82b4">EtatOpenGL::obtenirChaineGlRenderMode</a> () const </td></tr>
<tr class="memdesc:ga64d9bf10216007aeb301d43ac14f82b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_RENDER_MODE.  <a href="#ga64d9bf10216007aeb301d43ac14f82b4">More...</a><br/></td></tr>
<tr class="separator:ga64d9bf10216007aeb301d43ac14f82b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1596849dfe7b4606e0fc3ff9fbe00489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1596849dfe7b4606e0fc3ff9fbe00489">EtatOpenGL::obtenirChaineGlRgbaMode</a> () const </td></tr>
<tr class="memdesc:ga1596849dfe7b4606e0fc3ff9fbe00489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_RGBA_MODE.  <a href="#ga1596849dfe7b4606e0fc3ff9fbe00489">More...</a><br/></td></tr>
<tr class="separator:ga1596849dfe7b4606e0fc3ff9fbe00489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58f683f150a231ec839aed3f79cd3ef2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga58f683f150a231ec839aed3f79cd3ef2">EtatOpenGL::obtenirChaineGlScissorBox</a> () const </td></tr>
<tr class="memdesc:ga58f683f150a231ec839aed3f79cd3ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_SCISSOR_BOX.  <a href="#ga58f683f150a231ec839aed3f79cd3ef2">More...</a><br/></td></tr>
<tr class="separator:ga58f683f150a231ec839aed3f79cd3ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ed5d63c763521b6db8166033008a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga80ed5d63c763521b6db8166033008a6a">EtatOpenGL::obtenirChaineGlScissorTest</a> () const </td></tr>
<tr class="memdesc:ga80ed5d63c763521b6db8166033008a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_SCISSOR_TEST.  <a href="#ga80ed5d63c763521b6db8166033008a6a">More...</a><br/></td></tr>
<tr class="separator:ga80ed5d63c763521b6db8166033008a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae47f276d2d1d8233f544fca09b062e63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae47f276d2d1d8233f544fca09b062e63">EtatOpenGL::obtenirChaineGlSelectionBufferSize</a> () const </td></tr>
<tr class="memdesc:gae47f276d2d1d8233f544fca09b062e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_SELECTION_BUFFER_SIZE.  <a href="#gae47f276d2d1d8233f544fca09b062e63">More...</a><br/></td></tr>
<tr class="separator:gae47f276d2d1d8233f544fca09b062e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef3c863fd714bcd6607a7fe129c6c1d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaef3c863fd714bcd6607a7fe129c6c1d4">EtatOpenGL::obtenirChaineGlShadeModel</a> () const </td></tr>
<tr class="memdesc:gaef3c863fd714bcd6607a7fe129c6c1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_SHADE_MODEL.  <a href="#gaef3c863fd714bcd6607a7fe129c6c1d4">More...</a><br/></td></tr>
<tr class="separator:gaef3c863fd714bcd6607a7fe129c6c1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9001f71cc6ac9cb771d5e9eeedd69c5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9001f71cc6ac9cb771d5e9eeedd69c5a">EtatOpenGL::obtenirChaineGlStencilBits</a> () const </td></tr>
<tr class="memdesc:ga9001f71cc6ac9cb771d5e9eeedd69c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_STENCIL_BITS.  <a href="#ga9001f71cc6ac9cb771d5e9eeedd69c5a">More...</a><br/></td></tr>
<tr class="separator:ga9001f71cc6ac9cb771d5e9eeedd69c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0949a92c39c09a594a65cb035d992baf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga0949a92c39c09a594a65cb035d992baf">EtatOpenGL::obtenirChaineGlStencilClearValue</a> () const </td></tr>
<tr class="memdesc:ga0949a92c39c09a594a65cb035d992baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_STENCIL_CLEAR_VALUE.  <a href="#ga0949a92c39c09a594a65cb035d992baf">More...</a><br/></td></tr>
<tr class="separator:ga0949a92c39c09a594a65cb035d992baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3022225d3598456c739303b98e9d6ff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3022225d3598456c739303b98e9d6ff8">EtatOpenGL::obtenirChaineGlStencilFail</a> () const </td></tr>
<tr class="memdesc:ga3022225d3598456c739303b98e9d6ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_STENCIL_FAIL.  <a href="#ga3022225d3598456c739303b98e9d6ff8">More...</a><br/></td></tr>
<tr class="separator:ga3022225d3598456c739303b98e9d6ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1afa1d486d88c628562ec9e9ba6f6e10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1afa1d486d88c628562ec9e9ba6f6e10">EtatOpenGL::obtenirChaineGlStencilFunc</a> () const </td></tr>
<tr class="memdesc:ga1afa1d486d88c628562ec9e9ba6f6e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_STENCIL_FUNC.  <a href="#ga1afa1d486d88c628562ec9e9ba6f6e10">More...</a><br/></td></tr>
<tr class="separator:ga1afa1d486d88c628562ec9e9ba6f6e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e0217d78bce7c9e8aa865fa1b2d7e1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2e0217d78bce7c9e8aa865fa1b2d7e1f">EtatOpenGL::obtenirChaineGlStencilPassDepthFail</a> () const </td></tr>
<tr class="memdesc:ga2e0217d78bce7c9e8aa865fa1b2d7e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_STENCIL_PASS_DEPTH_FAIL.  <a href="#ga2e0217d78bce7c9e8aa865fa1b2d7e1f">More...</a><br/></td></tr>
<tr class="separator:ga2e0217d78bce7c9e8aa865fa1b2d7e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga722cf069559981c09c4b40810b37986f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga722cf069559981c09c4b40810b37986f">EtatOpenGL::obtenirChaineGlStencilPassDepthPass</a> () const </td></tr>
<tr class="memdesc:ga722cf069559981c09c4b40810b37986f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_STENCIL_PASS_DEPTH_PASS.  <a href="#ga722cf069559981c09c4b40810b37986f">More...</a><br/></td></tr>
<tr class="separator:ga722cf069559981c09c4b40810b37986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c961d29726d9daaf4d7cfc78025a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga31c961d29726d9daaf4d7cfc78025a6b">EtatOpenGL::obtenirChaineGlStencilRef</a> () const </td></tr>
<tr class="memdesc:ga31c961d29726d9daaf4d7cfc78025a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_STENCIL_REF.  <a href="#ga31c961d29726d9daaf4d7cfc78025a6b">More...</a><br/></td></tr>
<tr class="separator:ga31c961d29726d9daaf4d7cfc78025a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c3fb4e59ed994063e62893114882ad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3c3fb4e59ed994063e62893114882ad7">EtatOpenGL::obtenirChaineGlStencilTest</a> () const </td></tr>
<tr class="memdesc:ga3c3fb4e59ed994063e62893114882ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_STENCIL_TEST.  <a href="#ga3c3fb4e59ed994063e62893114882ad7">More...</a><br/></td></tr>
<tr class="separator:ga3c3fb4e59ed994063e62893114882ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f72c76847937fa57511a7758f43d43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga88f72c76847937fa57511a7758f43d43">EtatOpenGL::obtenirChaineGlStencilValueMask</a> () const </td></tr>
<tr class="memdesc:ga88f72c76847937fa57511a7758f43d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_STENCIL_VALUE_MASK.  <a href="#ga88f72c76847937fa57511a7758f43d43">More...</a><br/></td></tr>
<tr class="separator:ga88f72c76847937fa57511a7758f43d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dbeac5dc5d9ad85a54af632e3f96aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4dbeac5dc5d9ad85a54af632e3f96aac">EtatOpenGL::obtenirChaineGlStencilWritemask</a> () const </td></tr>
<tr class="memdesc:ga4dbeac5dc5d9ad85a54af632e3f96aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_STENCIL_WRITEMASK.  <a href="#ga4dbeac5dc5d9ad85a54af632e3f96aac">More...</a><br/></td></tr>
<tr class="separator:ga4dbeac5dc5d9ad85a54af632e3f96aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb2e39bc8896bcdd38587b23347df156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gadb2e39bc8896bcdd38587b23347df156">EtatOpenGL::obtenirChaineGlStereo</a> () const </td></tr>
<tr class="memdesc:gadb2e39bc8896bcdd38587b23347df156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_STEREO.  <a href="#gadb2e39bc8896bcdd38587b23347df156">More...</a><br/></td></tr>
<tr class="separator:gadb2e39bc8896bcdd38587b23347df156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga842fdba84c1a6dc5261e2e694732df1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga842fdba84c1a6dc5261e2e694732df1a">EtatOpenGL::obtenirChaineGlSubpixelBits</a> () const </td></tr>
<tr class="memdesc:ga842fdba84c1a6dc5261e2e694732df1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_SUBPIXEL_BITS.  <a href="#ga842fdba84c1a6dc5261e2e694732df1a">More...</a><br/></td></tr>
<tr class="separator:ga842fdba84c1a6dc5261e2e694732df1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60712e8970d469ba28a61541933011c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga60712e8970d469ba28a61541933011c4">EtatOpenGL::obtenirChaineGlTexture1D</a> () const </td></tr>
<tr class="memdesc:ga60712e8970d469ba28a61541933011c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_1D.  <a href="#ga60712e8970d469ba28a61541933011c4">More...</a><br/></td></tr>
<tr class="separator:ga60712e8970d469ba28a61541933011c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ef71bae62c28f023f69aa0838ef1b31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6ef71bae62c28f023f69aa0838ef1b31">EtatOpenGL::obtenirChaineGlTextureBinding1D</a> () const </td></tr>
<tr class="memdesc:ga6ef71bae62c28f023f69aa0838ef1b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_BINDING_1D.  <a href="#ga6ef71bae62c28f023f69aa0838ef1b31">More...</a><br/></td></tr>
<tr class="separator:ga6ef71bae62c28f023f69aa0838ef1b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c4d303e8a354ddb4678796eaceb45c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9c4d303e8a354ddb4678796eaceb45c6">EtatOpenGL::obtenirChaineGlTexture2D</a> () const </td></tr>
<tr class="memdesc:ga9c4d303e8a354ddb4678796eaceb45c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_2D.  <a href="#ga9c4d303e8a354ddb4678796eaceb45c6">More...</a><br/></td></tr>
<tr class="separator:ga9c4d303e8a354ddb4678796eaceb45c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga308bae30bed330cc281e0f2443cb43d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga308bae30bed330cc281e0f2443cb43d2">EtatOpenGL::obtenirChaineGlTextureBinding2D</a> () const </td></tr>
<tr class="memdesc:ga308bae30bed330cc281e0f2443cb43d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_BINDING_2D.  <a href="#ga308bae30bed330cc281e0f2443cb43d2">More...</a><br/></td></tr>
<tr class="separator:ga308bae30bed330cc281e0f2443cb43d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e3e42a091a09f20c4885d62bd29d1fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6e3e42a091a09f20c4885d62bd29d1fb">EtatOpenGL::obtenirChaineGlTextureCoordArray</a> () const </td></tr>
<tr class="memdesc:ga6e3e42a091a09f20c4885d62bd29d1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY.  <a href="#ga6e3e42a091a09f20c4885d62bd29d1fb">More...</a><br/></td></tr>
<tr class="separator:ga6e3e42a091a09f20c4885d62bd29d1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga874c08bb1dab5bf56279fa496f347017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga874c08bb1dab5bf56279fa496f347017">EtatOpenGL::obtenirChaineGlTextureCoordArraySize</a> () const </td></tr>
<tr class="memdesc:ga874c08bb1dab5bf56279fa496f347017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY_SIZE.  <a href="#ga874c08bb1dab5bf56279fa496f347017">More...</a><br/></td></tr>
<tr class="separator:ga874c08bb1dab5bf56279fa496f347017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cef5f78ea9815fc83b519aff2694d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga0cef5f78ea9815fc83b519aff2694d5b">EtatOpenGL::obtenirChaineGlTextureCoordArrayStride</a> () const </td></tr>
<tr class="memdesc:ga0cef5f78ea9815fc83b519aff2694d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY_STRIDE.  <a href="#ga0cef5f78ea9815fc83b519aff2694d5b">More...</a><br/></td></tr>
<tr class="separator:ga0cef5f78ea9815fc83b519aff2694d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cae6d3addddcf37939f5543fffab86f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6cae6d3addddcf37939f5543fffab86f">EtatOpenGL::obtenirChaineGlTextureCoordArrayType</a> () const </td></tr>
<tr class="memdesc:ga6cae6d3addddcf37939f5543fffab86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY_TYPE.  <a href="#ga6cae6d3addddcf37939f5543fffab86f">More...</a><br/></td></tr>
<tr class="separator:ga6cae6d3addddcf37939f5543fffab86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc696d575361d0668e25ab8f8455c21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2bc696d575361d0668e25ab8f8455c21">EtatOpenGL::obtenirChaineGlTextureGenQ</a> () const </td></tr>
<tr class="memdesc:ga2bc696d575361d0668e25ab8f8455c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_GEN_Q.  <a href="#ga2bc696d575361d0668e25ab8f8455c21">More...</a><br/></td></tr>
<tr class="separator:ga2bc696d575361d0668e25ab8f8455c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga232ca6071605477892ccd38781f48b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga232ca6071605477892ccd38781f48b53">EtatOpenGL::obtenirChaineGlTextureGenR</a> () const </td></tr>
<tr class="memdesc:ga232ca6071605477892ccd38781f48b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_GEN_R.  <a href="#ga232ca6071605477892ccd38781f48b53">More...</a><br/></td></tr>
<tr class="separator:ga232ca6071605477892ccd38781f48b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac92ef30b356fe2de552d88b455aa0b20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac92ef30b356fe2de552d88b455aa0b20">EtatOpenGL::obtenirChaineGlTextureGenS</a> () const </td></tr>
<tr class="memdesc:gac92ef30b356fe2de552d88b455aa0b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_GEN_S.  <a href="#gac92ef30b356fe2de552d88b455aa0b20">More...</a><br/></td></tr>
<tr class="separator:gac92ef30b356fe2de552d88b455aa0b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa225300590e106cd32d3a011d1ff6599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa225300590e106cd32d3a011d1ff6599">EtatOpenGL::obtenirChaineGlTextureGenT</a> () const </td></tr>
<tr class="memdesc:gaa225300590e106cd32d3a011d1ff6599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_GEN_T.  <a href="#gaa225300590e106cd32d3a011d1ff6599">More...</a><br/></td></tr>
<tr class="separator:gaa225300590e106cd32d3a011d1ff6599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21a2e048b745fe84c5befbd361f2f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad21a2e048b745fe84c5befbd361f2f5e">EtatOpenGL::obtenirChaineGlTextureMatrix</a> () const </td></tr>
<tr class="memdesc:gad21a2e048b745fe84c5befbd361f2f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_MATRIX.  <a href="#gad21a2e048b745fe84c5befbd361f2f5e">More...</a><br/></td></tr>
<tr class="separator:gad21a2e048b745fe84c5befbd361f2f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278f05112b89edd0cbb3d601d73fadb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga278f05112b89edd0cbb3d601d73fadb4">EtatOpenGL::obtenirChaineGlTextureStackDepth</a> () const </td></tr>
<tr class="memdesc:ga278f05112b89edd0cbb3d601d73fadb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_TEXTURE_STACK_DEPTH.  <a href="#ga278f05112b89edd0cbb3d601d73fadb4">More...</a><br/></td></tr>
<tr class="separator:ga278f05112b89edd0cbb3d601d73fadb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcc3fe54f0a5f429af71e1bacef5a9c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gabcc3fe54f0a5f429af71e1bacef5a9c9">EtatOpenGL::obtenirChaineGlUnpackAlignment</a> () const </td></tr>
<tr class="memdesc:gabcc3fe54f0a5f429af71e1bacef5a9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_UNPACK_ALIGNMENT.  <a href="#gabcc3fe54f0a5f429af71e1bacef5a9c9">More...</a><br/></td></tr>
<tr class="separator:gabcc3fe54f0a5f429af71e1bacef5a9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5de4612f68058b5bc47576fc64f97004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5de4612f68058b5bc47576fc64f97004">EtatOpenGL::obtenirChaineGlUnpackLsbFirst</a> () const </td></tr>
<tr class="memdesc:ga5de4612f68058b5bc47576fc64f97004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_UNPACK_LSB_FIRST.  <a href="#ga5de4612f68058b5bc47576fc64f97004">More...</a><br/></td></tr>
<tr class="separator:ga5de4612f68058b5bc47576fc64f97004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefbf6604571a413d33c117cb1c170a79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaefbf6604571a413d33c117cb1c170a79">EtatOpenGL::obtenirChaineGlUnpackRowLength</a> () const </td></tr>
<tr class="memdesc:gaefbf6604571a413d33c117cb1c170a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_UNPACK_ROW_LENGTH.  <a href="#gaefbf6604571a413d33c117cb1c170a79">More...</a><br/></td></tr>
<tr class="separator:gaefbf6604571a413d33c117cb1c170a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0abd9dc2b1158d657d9553424732bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa0abd9dc2b1158d657d9553424732bb8">EtatOpenGL::obtenirChaineGlUnpackSkipPixels</a> () const </td></tr>
<tr class="memdesc:gaa0abd9dc2b1158d657d9553424732bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_UNPACK_SKIP_PIXELS.  <a href="#gaa0abd9dc2b1158d657d9553424732bb8">More...</a><br/></td></tr>
<tr class="separator:gaa0abd9dc2b1158d657d9553424732bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4065b05943d7e949fd785f85dd3cdc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa4065b05943d7e949fd785f85dd3cdc2">EtatOpenGL::obtenirChaineGlUnpackSkipRows</a> () const </td></tr>
<tr class="memdesc:gaa4065b05943d7e949fd785f85dd3cdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_UNPACK_SKIP_ROWS.  <a href="#gaa4065b05943d7e949fd785f85dd3cdc2">More...</a><br/></td></tr>
<tr class="separator:gaa4065b05943d7e949fd785f85dd3cdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b797c3176f4a4cb2094550ebaab4d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa9b797c3176f4a4cb2094550ebaab4d9">EtatOpenGL::obtenirChaineGlUnpackSwapBytes</a> () const </td></tr>
<tr class="memdesc:gaa9b797c3176f4a4cb2094550ebaab4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_UNPACK_SWAP_BYTES.  <a href="#gaa9b797c3176f4a4cb2094550ebaab4d9">More...</a><br/></td></tr>
<tr class="separator:gaa9b797c3176f4a4cb2094550ebaab4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa758212d7a3f274415edbc9e2532289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaaa758212d7a3f274415edbc9e2532289">EtatOpenGL::obtenirChaineGlVertexArray</a> () const </td></tr>
<tr class="memdesc:gaaa758212d7a3f274415edbc9e2532289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_VERTEX_ARRAY.  <a href="#gaaa758212d7a3f274415edbc9e2532289">More...</a><br/></td></tr>
<tr class="separator:gaaa758212d7a3f274415edbc9e2532289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5475c8155f182e7c018cca2f6124f746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5475c8155f182e7c018cca2f6124f746">EtatOpenGL::obtenirChaineGlVertexArraySize</a> () const </td></tr>
<tr class="memdesc:ga5475c8155f182e7c018cca2f6124f746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_VERTEX_ARRAY_SIZE.  <a href="#ga5475c8155f182e7c018cca2f6124f746">More...</a><br/></td></tr>
<tr class="separator:ga5475c8155f182e7c018cca2f6124f746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7830e4ba0be698e54d824a5c6a430f5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7830e4ba0be698e54d824a5c6a430f5d">EtatOpenGL::obtenirChaineGlVertexArrayStride</a> () const </td></tr>
<tr class="memdesc:ga7830e4ba0be698e54d824a5c6a430f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_VERTEX_ARRAY_STRIDE.  <a href="#ga7830e4ba0be698e54d824a5c6a430f5d">More...</a><br/></td></tr>
<tr class="separator:ga7830e4ba0be698e54d824a5c6a430f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27df79ce6a4279f818c5cd041e8dc6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga27df79ce6a4279f818c5cd041e8dc6bd">EtatOpenGL::obtenirChaineGlVertexArrayType</a> () const </td></tr>
<tr class="memdesc:ga27df79ce6a4279f818c5cd041e8dc6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_VERTEX_ARRAY_TYPE.  <a href="#ga27df79ce6a4279f818c5cd041e8dc6bd">More...</a><br/></td></tr>
<tr class="separator:ga27df79ce6a4279f818c5cd041e8dc6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6afc9840c8a03deb6d741843bf82d28d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6afc9840c8a03deb6d741843bf82d28d">EtatOpenGL::obtenirChaineGlViewport</a> () const </td></tr>
<tr class="memdesc:ga6afc9840c8a03deb6d741843bf82d28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_VIEWPORT.  <a href="#ga6afc9840c8a03deb6d741843bf82d28d">More...</a><br/></td></tr>
<tr class="separator:ga6afc9840c8a03deb6d741843bf82d28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca35baf35a77d201c5a770a22aedbe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8ca35baf35a77d201c5a770a22aedbe8">EtatOpenGL::obtenirChaineGlZoomX</a> () const </td></tr>
<tr class="memdesc:ga8ca35baf35a77d201c5a770a22aedbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ZOOM_X.  <a href="#ga8ca35baf35a77d201c5a770a22aedbe8">More...</a><br/></td></tr>
<tr class="separator:ga8ca35baf35a77d201c5a770a22aedbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4231723bc8a26f191c53329dceed9222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4231723bc8a26f191c53329dceed9222">EtatOpenGL::obtenirChaineGlZoomY</a> () const </td></tr>
<tr class="memdesc:ga4231723bc8a26f191c53329dceed9222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne representant l'attribut GL_ZOOM_Y.  <a href="#ga4231723bc8a26f191c53329dceed9222">More...</a><br/></td></tr>
<tr class="separator:ga4231723bc8a26f191c53329dceed9222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga349c289d77c484b8b4a180843d968b46"><td class="memItemLeft" align="right" valign="top">static T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga349c289d77c484b8b4a180843d968b46">Singleton&lt; T &gt;::obtenirInstance</a> ()</td></tr>
<tr class="memdesc:ga349c289d77c484b8b4a180843d968b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtient l'instance unique de la classe.  <a href="#ga349c289d77c484b8b4a180843d968b46">More...</a><br/></td></tr>
<tr class="separator:ga349c289d77c484b8b4a180843d968b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b9ae943a004663d769be3f08ae35a0f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="wglew_8h.html#aeea6e3dfae3acf232096f57d2d57f084">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2b9ae943a004663d769be3f08ae35a0f">Singleton&lt; T &gt;::libererInstance</a> ()</td></tr>
<tr class="memdesc:ga2b9ae943a004663d769be3f08ae35a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Libere l'instance unique de la classe.  <a href="#ga2b9ae943a004663d769be3f08ae35a0f">More...</a><br/></td></tr>
<tr class="separator:ga2b9ae943a004663d769be3f08ae35a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gacd82c66571930dca394095824ff37a5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COMPARER_DEFAUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a></td><td>)</td>
          <td>&#160;&#160;&#160;return &quot;GL_??? (&quot; + utilitaire::convertirEnChaine(<a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>) + &quot;)&quot;;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cette macro retourne la valeur par defaut de la variable. </p>

</div>
</div>
<a class="anchor" id="ga849df54224f798741d3fe046180dddfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COMPARER_VALEUR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chaine&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;if (<a class="el" href="glew_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a> == chaine) return #chaine ;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cette macro permet de retourner la chaîne associee a une valeur. </p>

</div>
</div>
<a class="anchor" id="gae90f81f48642444b4ba7fa5cacf40569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GL_CLAMP_TO_EDGE&#160;&#160;&#160;0x812F</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7e8b3c8482e593df0ace933ad3de22ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RATIO&#160;&#160;&#160;(16.0f/9.0f)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1e4ee9d5709f277c392eea80755d85d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SINGLETON_DECLARATION_CLASSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Classe</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">private</span>:                                     \</div>
<div class="line">   Classe () {}                              \</div>
<div class="line">   ~ Classe () {}                            \</div>
<div class="line">   Classe ( <span class="keyword">const</span> Classe&amp; );                 \</div>
<div class="line">   Classe &amp; operator = ( <span class="keyword">const</span> Classe&amp; );    \</div>
<div class="line">   friend <span class="keyword">class </span><a class="code" href="class_singleton.html">Singleton</a>&lt; Classe &gt;;         \</div>
<div class="ttc" id="class_singleton_html"><div class="ttname"><a href="class_singleton.html">Singleton</a></div><div class="ttdoc">Cette classe represente une base generique pour la declaration de singleton. </div><div class="ttdef"><b>Definition:</b> Singleton.h:28</div></div>
</div><!-- fragment --><p>Cette macro doit etre incluse dans les classes derivees de <a class="el" href="class_singleton.html" title="Cette classe represente une base generique pour la declaration de singleton. ">Singleton</a>. Elle declare les constructeurs et destructeurs prives. </p>

</div>
</div>
<a class="anchor" id="ga4e5462d4b058b18eaee177c1f3f50964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SINGLETON_DECLARATION_CLASSE_SANS_CONSTRUCTEUR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Classe</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">private</span>:                                                       \</div>
<div class="line">   Classe( <span class="keyword">const</span> Classe&amp; );                                  \</div>
<div class="line">   Classe&amp; operator=( <span class="keyword">const</span> Classe&amp; );                     \</div>
<div class="line">   friend <span class="keyword">class </span><a class="code" href="class_singleton.html">Singleton</a>&lt; Classe &gt;;                           \</div>
<div class="ttc" id="class_singleton_html"><div class="ttname"><a href="class_singleton.html">Singleton</a></div><div class="ttdoc">Cette classe represente une base generique pour la declaration de singleton. </div><div class="ttdef"><b>Definition:</b> Singleton.h:28</div></div>
</div><!-- fragment --><p>Cette macro doit etre incluse dans les classes derivees de <a class="el" href="class_singleton.html" title="Cette classe represente une base generique pour la declaration de singleton. ">Singleton</a>. Elle declare le constructeur copie et l'operateur d'assignation prive, en laissant a la classe derivee le soin de definir le constructeur par defaut et le destructeur afin de faire le traitement souhaite. </p>

</div>
</div>
<a class="anchor" id="gafd88a0bb7182bc9164ab9200f31e6340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SINGLETON_DECLARATION_CPP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Classe</td><td>)</td>
          <td>&#160;&#160;&#160;Classe * <a class="el" href="class_singleton.html">Singleton</a>&lt; Classe &gt;::instance_ = 0; \</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga6f7808e68c967b90bd7e737b7e1b78de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_vecteur2_d.html">Vecteur2D</a>&lt;double&gt; <a class="el" href="group__utilitaire.html#ga6f7808e68c967b90bd7e737b7e1b78de">Vecteur2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition de type de vecteur a 2 coordonnees de type double. </p>

</div>
</div>
<a class="anchor" id="ga606b191c0b0bbb868ae25c13b906f45a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_vecteur2_d.html">Vecteur2D</a>&lt;<a class="el" href="fmod_8h.html#aeb841aa4b4b5f444b5d739d865b420af">float</a>&gt; <a class="el" href="group__utilitaire.html#ga606b191c0b0bbb868ae25c13b906f45a">Vecteur2f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition de type de vecteur a 2 coordonnees de type float. </p>

</div>
</div>
<a class="anchor" id="gaec90ef57a6e09fb50982434719093ccf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_vecteur2_d.html">Vecteur2D</a>&lt;<a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a>&gt; <a class="el" href="group__utilitaire.html#gaec90ef57a6e09fb50982434719093ccf">Vecteur2i</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition de type de vecteur a 2 coordonnees de type int. </p>

</div>
</div>
<a class="anchor" id="ga541aa4837ad9250d3a248dc82ee9ad4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_vecteur3_d.html">Vecteur3D</a>&lt;double&gt; <a class="el" href="group__utilitaire.html#ga541aa4837ad9250d3a248dc82ee9ad4d">Vecteur3</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition de type de vecteur a 3 coordonnees de type double. </p>

</div>
</div>
<a class="anchor" id="ga6b2956069f76c7e27df4f79f87e5a48c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_vecteur3_d.html">Vecteur3D</a>&lt;<a class="el" href="fmod_8h.html#aeb841aa4b4b5f444b5d739d865b420af">float</a>&gt; <a class="el" href="group__utilitaire.html#ga6b2956069f76c7e27df4f79f87e5a48c">Vecteur3f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition de type de vecteur a 3 coordonnees de type float. </p>

</div>
</div>
<a class="anchor" id="ga5ba46df25fc97cf509fc2d1f89dc9674"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_vecteur3_d.html">Vecteur3D</a>&lt;<a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a>&gt; <a class="el" href="group__utilitaire.html#ga5ba46df25fc97cf509fc2d1f89dc9674">Vecteur3i</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition de type de vecteur a 3 coordonnees de type int. </p>

</div>
</div>
<a class="anchor" id="ga74210b298fac77de71eff58f3dd3ddb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_vecteur4_d.html">Vecteur4D</a>&lt;double&gt; <a class="el" href="group__utilitaire.html#ga74210b298fac77de71eff58f3dd3ddb6">Vecteur4</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition de type de vecteur a 4 coordonnees de type double. </p>

</div>
</div>
<a class="anchor" id="ga6a8205c734fc1c9d1272ea424efb2606"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_vecteur4_d.html">Vecteur4D</a>&lt;<a class="el" href="fmod_8h.html#aeb841aa4b4b5f444b5d739d865b420af">float</a>&gt; <a class="el" href="group__utilitaire.html#ga6a8205c734fc1c9d1272ea424efb2606">Vecteur4f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition de type de vecteur a 4 coordonnees de type float. </p>

</div>
</div>
<a class="anchor" id="gad4b5a2b41dda0bd067bf74ae33b473a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_vecteur4_d.html">Vecteur4D</a>&lt;<a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a>&gt; <a class="el" href="group__utilitaire.html#gad4b5a2b41dda0bd067bf74ae33b473a8">Vecteur4i</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition de type de vecteur a 4 coordonnees de type int. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5b5846202001fecd71cd2a0afbbdb494"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CEcritureFichierBinaire::CEcritureFichierBinaire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par defaut. </p>
<p>Constructeur par defaut qui ne fait rien.</p>
<dl class="section return"><dt>Returns</dt><dd>Aucune (constructeur). </dd></dl>

</div>
</div>
<a class="anchor" id="gad19b9753aa12a9f25fd0febc3c899024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CEcritureFichierBinaire::CEcritureFichierBinaire </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nomFichier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">openmode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>std::ios::out&#160;|&#160;<a class="el" href="glew_8h.html#a0ace813ee1f7020974174eb65d53ff0d">std::ios::binary</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par parametre. </p>
<p>Constructeur par parametres: ouvre un fichier binaire.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nomFichier</td><td>: Le nom du fichier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>: Le mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aucune (constructeur). </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a259905a2c14513846e6ecb8cf476ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CLectureFichierBinaire::CLectureFichierBinaire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par defaut. </p>
<p>Constructeur par defaut qui ne fait rien.</p>
<dl class="section return"><dt>Returns</dt><dd>Aucune (constructeur). </dd></dl>

</div>
</div>
<a class="anchor" id="gac16ebab7b172408c2ba14605f61f0f84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CLectureFichierBinaire::CLectureFichierBinaire </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nomFichier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">openmode&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="glew_8h.html#a83ad0ee7f1e06b59c90271716e689080">std::ios::in</a>&#160;|&#160;<a class="el" href="glew_8h.html#a0ace813ee1f7020974174eb65d53ff0d">std::ios::binary</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par parametre. </p>
<p>Constructeur par parametres: ouvre un fichier binaire.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nomFichier</td><td>: Le nom du fichier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>: Le mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aucune </dd></dl>

</div>
</div>
<a class="anchor" id="gaf682f61929f2502b08b6b88de07349b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EtatOpenGL::EtatOpenGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par defaut. </p>
<p>Ce constructeur lit toutes ses variables de l'etat courant de la machine OpenGL.</p>
<dl class="section return"><dt>Returns</dt><dd>Aucune (constructeur). </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b9ae943a004663d769be3f08ae35a0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="wglew_8h.html#aeea6e3dfae3acf232096f57d2d57f084">void</a> <a class="el" href="class_singleton.html">Singleton</a>&lt; T &gt;::libererInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Libere l'instance unique de la classe. </p>
<p>Detruit l'instance unique de la classe. Cette fonction n'est pas "thread-safe".</p>
<dl class="section return"><dt>Returns</dt><dd>Aucune. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7145545254c30909311d3b1ef0bdd07a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="wglew_8h.html#aeea6e3dfae3acf232096f57d2d57f084">void</a> CEcritureFichierBinaire::null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction pour inserer des caracteres vides dans le fichier. </p>
<p>Cette fonction permet d'inserer des caracters nuls (0) dans le fichier binaire.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: Le nombre de caracteres vides a inserer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aucune </dd></dl>

</div>
</div>
<a class="anchor" id="ga13c8aaca9f02431b47b83e36b18f8067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAccumAlphaBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ACCUM_ALPHA_BITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ACCUM_ALPHA_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of alpha bitplanes in the accumulation buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ACCUM_ALPHA_BITS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga695387ee2d838c97214c70219d52da10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAccumBlueBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ACCUM_BLUE_BITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ACCUM_BLUE_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of blue bitplanes in the accumulation buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ACCUM_BLUE_BITS. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3e85f5f434e93aa09376200f3c837ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAccumClearValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ACCUM_CLEAR_VALUE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ACCUM_CLEAR_VALUE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the red, green, blue, and alpha values used to clear the accumulation buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See glClearAccum.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ACCUM_CLEAR_VALUE. </dd></dl>

</div>
</div>
<a class="anchor" id="gae677b60d2113b1843ba4d2c92fe34c34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAccumGreenBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ACCUM_GREEN_BITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ACCUM_GREEN_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of green bitplanes in the accumulation buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ACCUM_GREEN_BITS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3405a98de14c30d7a57d954d298b6376"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAccumRedBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ACCUM_RED_BITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ACCUM_RED_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of red bitplanes in the accumulation buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ACCUM_RED_BITS. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf54d9525863334d2d2fd362c7043a4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAlphaBias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ALPHA_BIAS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ALPHA_BIAS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the alpha bias factor used during pixel transfers. The initial value is 0. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ALPHA_BIAS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ea311e8cfd6aee3cb19e2041b2ba132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAlphaBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ALPHA_BITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ALPHA_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of alpha bitplanes in each color buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ALPHA_BITS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b85b93cd7e5d1f12a225f28ece00696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAlphaScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ALPHA_SCALE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ALPHA_SCALE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the alpha scale factor used during pixel transfers. The initial value is 1. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ALPHA_SCALE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9fd2e2270997cf027e38f6a7b8d621a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAlphaTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ALPHA_TEST. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ALPHA_TEST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether alpha testing of fragments is enabled. The initial value is GL_FALSE. See glAlphaFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ALPHA_TEST. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5002fd87fb9aede24afc4c4bb2a61fb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAlphaTestFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ALPHA_TEST_FUNC. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ALPHA_TEST_FUNC.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the symbolic name of the alpha test function. The initial value is GL_ALWAYS. See glAlphaFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ALPHA_TEST_FUNC. </dd></dl>

</div>
</div>
<a class="anchor" id="gacc2904dcf7edec91f24e5e6ea58a780c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAlphaTestRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ALPHA_TEST_REF. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ALPHA_TEST_REF.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the reference value for the alpha test. The initial value is 0. See glAlphaFunc. An integer value, if requested, is linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ALPHA_TEST_REF. </dd></dl>

</div>
</div>
<a class="anchor" id="ga59c1e206aa477f625b5499cf328f695b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAttribStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ATTRIB_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ATTRIB_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the depth of the attribute stack. If the stack is empty, 0 is returned. The initial value is 0. See glPushAttrib.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ATTRIB_STACK_DEPTH. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf8d3f8a4dd51812950c32268c8f77c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAutoNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_AUTO_NORMAL. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_AUTO_NORMAL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D map evaluation automatically generates surface normals. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_AUTO_NORMAL. </dd></dl>

</div>
</div>
<a class="anchor" id="gab8c780e176faece6cbaa11084e957e8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlAuxBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_AUX_BUFFERS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_AUX_BUFFERS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of auxiliary color buffers. The initial value is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_AUX_BUFFERS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a5f949f2b7a9a911c0677d639bebae5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlBlend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_BLEND. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_BLEND.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether blending is enabled. The initial value is GL_FALSE. See glBlendFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_BLEND. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa52ab39bcb62d4f8777afddfca458650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlBlendDst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_BLEND_DST. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_BLEND_DST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the symbolic constant identifying the destination blend function. The initial value is GL_ZERO. See glBlendFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_BLEND_DST. </dd></dl>

</div>
</div>
<a class="anchor" id="ga510a36fe5d3e313756e40b5c67b516ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlBlendSrc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_BLEND_SRC. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_BLEND_SRC.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the symbolic constant identifying the source blend function. The initial value is GL_ONE. See glBlendFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_BLEND_SRC. </dd></dl>

</div>
</div>
<a class="anchor" id="ga95f9a6baabd65a0cdd4b1e5cbeb4f678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlBlueBias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_BLUE_BIAS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_BLUE_BIAS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the blue bias factor used during pixel transfers. The initial value is 0. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_BLUE_BIAS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga125172f1c5c4ef27c20c4e52a70ce38a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlBlueBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_BLUE_BITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_BLUE_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of blue bitplanes in each color buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_BLUE_BITS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8422f585aba4fc07dcaac22e6cf587b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlBlueScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_BLUE_SCALE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_BLUE_SCALE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the blue scale factor used during pixel transfers. The initial value is 1. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_BLUE_SCALE. </dd></dl>

</div>
</div>
<a class="anchor" id="gad57f6d8da9cffeae2204a77e6e5f9292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlClientAttribStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CLIENT_ATTRIB_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CLIENT_ATTRIB_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value indicating the depth of the attribute stack. The initial value is 0. See glPushClientAttrib.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CLIENT_ATTRIB_STACK_DEPTH. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7deb847efbc619585d5e8c9f6600204c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlClipPlanei </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CLIP_PLANEi. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CLIP_PLANEi.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the specified clipping plane is enabled. The initial value is GL_FALSE. See glClipPlane.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CLIP_PLANEi. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fae4f702f9be3574209f0721b6768ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlColorArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_COLOR_ARRAY. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_COLOR_ARRAY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the color array is enabled. The initial value is GL_FALSE. See glColorPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_COLOR_ARRAY. </dd></dl>

</div>
</div>
<a class="anchor" id="gad1e82d8c71b8e2a76c806e1c92cbb669"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlColorArraySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_COLOR_ARRAY_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_COLOR_ARRAY_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of components per color in the color array. The initial value is 4. See glColorPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_COLOR_ARRAY_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="gab499d52456b097364de8300cc6af6808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlColorArrayStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_COLOR_ARRAY_STRIDE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_COLOR_ARRAY_STRIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte offset between consecutive colors in the color array. The initial value is 0. See glColorPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_COLOR_ARRAY_STRIDE. </dd></dl>

</div>
</div>
<a class="anchor" id="gae77f9acd8bdebe2e7bb39660e03b3e28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlColorArrayType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_COLOR_ARRAY_TYPE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_COLOR_ARRAY_TYPE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the data type of each component in the color array. The initial value is GL_FLOAT. See glColorPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_COLOR_ARRAY_TYPE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7de74c129bd5c5038e7f3d03a5508f72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlColorClearValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_COLOR_CLEAR_VALUE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_COLOR_CLEAR_VALUE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See glClearColor.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_COLOR_CLEAR_VALUE. </dd></dl>

</div>
</div>
<a class="anchor" id="gac48e5f8e10bfcd96670a537164a0a8ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlColorLogicOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_COLOR_LOGIC_OP. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_COLOR_LOGIC_OP.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. The initial value is GL_FALSE. See glLogicOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_COLOR_LOGIC_OP. </dd></dl>

</div>
</div>
<a class="anchor" id="gae53c823bf9d4e4305baf00f4d7da96af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlColorMaterial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_COLOR_MATERIAL. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_COLOR_MATERIAL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether one or more material parameters are tracking the current color. The initial value is GL_FALSE. See glColorMaterial.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_COLOR_MATERIAL. </dd></dl>

</div>
</div>
<a class="anchor" id="gaec66f0ae860a11d50b0e1cf2def483bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlColorMaterialFace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_COLOR_MATERIAL_FACE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_COLOR_MATERIAL_FACE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating which materials have a parameter that is tracking the current color. The initial value is GL_FRONT_AND_BACK. See glColorMaterial.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_COLOR_MATERIAL_FACE. </dd></dl>

</div>
</div>
<a class="anchor" id="gad2b7f4282f94a24c4b5129854732c36a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlColorMaterialParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_COLOR_MATERIAL_PARAMETER. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_COLOR_MATERIAL_PARAMETER.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating which material parameters are tracking the current color. The initial value is GL_AMBIENT_AND_DIFFUSE. See glColorMaterial.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_COLOR_MATERIAL_PARAMETER. </dd></dl>

</div>
</div>
<a class="anchor" id="ga677eb5add1db0999f73a7c6febefe4d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlColorWritemask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_COLOR_WRITEMASK. </p>

</div>
</div>
<a class="anchor" id="ga6c53044cfb9b67582efe6415ff1f1f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlCullFace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CULL_FACE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CULL_FACE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether polygon culling is enabled. The initial value is GL_FALSE. See glCullFace.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CULL_FACE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0601a9f84791de8e9ab33841308ecea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlCullFaceMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CULL_FACE_MODE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CULL_FACE_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating which polygon faces are to be culled. The initial value is GL_BACK. See glCullFace.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CULL_FACE_MODE. </dd></dl>

</div>
</div>
<a class="anchor" id="gabe349174d65850291bc46f7b524dac44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlCurrentColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CURRENT_COLOR. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CURRENT_COLOR.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the red, green, blue, and alpha values of the current color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See glColor. The initial value is (1, 1, 1, 1).</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CURRENT_COLOR. </dd></dl>

</div>
</div>
<a class="anchor" id="ga222790a07e4a9cacfbe2f68cd97fd8d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlCurrentIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CURRENT_INDEX. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CURRENT_INDEX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the current color index. The initial value is 1. See glIndex.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CURRENT_INDEX. </dd></dl>

</div>
</div>
<a class="anchor" id="gac6c54789d936998634ad29c80e150d92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlCurrentNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CURRENT_NORMAL. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CURRENT_NORMAL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns three values: the x, y, and z values of the current normal. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 0, 1). See glNormal.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CURRENT_NORMAL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62ef22c97a3ecc8c7e956f2fd7267b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlCurrentRasterColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CURRENT_RASTER_COLOR. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CURRENT_RASTER_COLOR.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the red, green, blue, and alpha values of the current raster position. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (1, 1, 1, 1). See glRasterPos.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CURRENT_RASTER_COLOR. </dd></dl>

</div>
</div>
<a class="anchor" id="ga130c72bf45a65d7d7770c77c7f71cf5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlCurrentRasterDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CURRENT_RASTER_DISTANCE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CURRENT_RASTER_DISTANCE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the distance from the eye to the current raster position. The initial value is 0. See glRasterPos.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CURRENT_RASTER_DISTANCE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9d14728a6f086186ff9ec92738952892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlCurrentRasterIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CURRENT_RASTER_INDEX. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CURRENT_RASTER_INDEX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the color index of the current raster position. The initial value is 1. See glRasterPos.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CURRENT_RASTER_INDEX. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1151f4eee3a50e14e0157b18b6fefaa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlCurrentRasterPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CURRENT_RASTER_POSITION. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CURRENT_RASTER_POSITION.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the x, y, z, and w components of the current raster position. x, y, and z are in window coordinates, and w is in clip coordinates. The initial value is (0, 0, 0, 1). See glRasterPos.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CURRENT_RASTER_POSITION. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa95c762062531085430d3bd8381c1ab1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlCurrentRasterPositionValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CURRENT_RASTER_POSITION_VALID. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CURRENT_RASTER_POSITION_VALID.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the current raster position is valid. The initial value is GL_TRUE. See glRasterPos.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CURRENT_RASTER_POSITION_VALID. </dd></dl>

</div>
</div>
<a class="anchor" id="gae1b30e504db9237dce13eade239c8c5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlCurrentRasterTextureCoords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CURRENT_RASTER_TEXTURE_COORDS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CURRENT_RASTER_TEXTURE_COORDS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the s, t, r, and q current raster texture coordinates. The initial value is (0, 0, 0, 1). See glRasterPos and glTexCoord.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CURRENT_RASTER_TEXTURE_COORDS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5bf6abadfe9d63e576d34c94c93ee8f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlCurrentTextureCoords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_CURRENT_TEXTURE_COORDS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_CURRENT_TEXTURE_COORDS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the s, t, r, and q current texture coordinates. The initial value is (0, 0, 0, 1). See glTexCoord.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_CURRENT_TEXTURE_COORDS. </dd></dl>

</div>
</div>
<a class="anchor" id="gae3e587b7e9f860f3874823a3c4ab7d71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlDepthBias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_DEPTH_BIAS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_DEPTH_BIAS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the depth bias factor used during pixel transfers. The initial value is 0. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_DEPTH_BIAS. </dd></dl>

</div>
</div>
<a class="anchor" id="gae1dffc44c8e27d7cb249064cfe35653e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlDepthBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_DEPTH_BITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_DEPTH_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of bitplanes in the depth buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_DEPTH_BITS. </dd></dl>

</div>
</div>
<a class="anchor" id="gad8b3e2701fb07b0178b5015868818509"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlDepthClearValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_DEPTH_CLEAR_VALUE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_DEPTH_CLEAR_VALUE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is 1. See glClearDepth.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_DEPTH_CLEAR_VALUE. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0dff9e4aee8f969fe6e688bb407dcc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlDepthFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_DEPTH_FUNC. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_DEPTH_FUNC.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the symbolic constant that indicates the depth comparison function. The initial value is GL_LESS. See glDepthFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_DEPTH_FUNC. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9921b541644f4dc3b64a4ffd4a661a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlDepthRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_DEPTH_RANGE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_DEPTH_RANGE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 1). See glDepthRange.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_DEPTH_RANGE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fac162003ef8c012c16ecd9041794ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlDepthScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_DEPTH_SCALE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_DEPTH_SCALE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the depth scale factor used during pixel transfers. The initial value is 1. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_DEPTH_SCALE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga712bcce1fd6c63377d2b3c9c421f7559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlDepthTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_DEPTH_TEST. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_DEPTH_TEST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether depth testing of fragments is enabled. The initial value is GL_FALSE. See glDepthFunc and glDepthRange.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_DEPTH_TEST. </dd></dl>

</div>
</div>
<a class="anchor" id="gaec88db9c85bfd66909d3172982025862"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlDepthWritemask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_DEPTH_WRITEMASK. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_DEPTH_WRITEMASK.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating if the depth buffer is enabled for writing. The initial value is GL_TRUE. See glDepthMask.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_DEPTH_WRITEMASK. </dd></dl>

</div>
</div>
<a class="anchor" id="gabc6e75dad01908ff21a473d75483f691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlDither </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_DITHER. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_DITHER.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether dithering of fragment colors and indices is enabled. The initial value is GL_TRUE.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_DITHER. </dd></dl>

</div>
</div>
<a class="anchor" id="gae8239c45bba646389f06a6bdd49670f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlDoublebuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_DOUBLEBUFFER. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_DOUBLEBUFFER.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether double buffering is supported.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_DOUBLEBUFFER. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b705291c7da107645656d5dfb51872a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlDrawBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_DRAW_BUFFER. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_DRAW_BUFFER.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating which buffers are being drawn to. See glDrawBuffer. The initial value is GL_BACK if there are back buffers, otherwise it is GL_FRONT.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_DRAW_BUFFER. </dd></dl>

</div>
</div>
<a class="anchor" id="ga982e0dacd18861db40bc153b8e7748d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlEdgeFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_EDGE_FLAG. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_EDGE_FLAG.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the current edge flag is GL_TRUE or GL_FALSE. The initial value is GL_TRUE. See glEdgeFlag.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_EDGE_FLAG. </dd></dl>

</div>
</div>
<a class="anchor" id="gac69166db434f3671eb241b00786be34b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlEdgeFlagArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_EDGE_FLAG_ARRAY. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_EDGE_FLAG_ARRAY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the edge flag array is enabled. The initial value is GL_FALSE. See glEdgeFlagPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_EDGE_FLAG_ARRAY. </dd></dl>

</div>
</div>
<a class="anchor" id="ga12932637a943b952d6c822af48b4102a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlEdgeFlagArrayStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_EDGE_FLAG_ARRAY_STRIDE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_EDGE_FLAG_ARRAY_STRIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte offset between consecutive edge flags in the edge flag array. The initial value is 0. See glEdgeFlagPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_EDGE_FLAG_ARRAY_STRIDE. </dd></dl>

</div>
</div>
<a class="anchor" id="gab0ae8d230f1fe733862032e082cfbd2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlFeedbackBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_FEEDBACK_BUFFER_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_FEEDBACK_BUFFER_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the feedback buffer. See glFeedbackBuffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_FEEDBACK_BUFFER_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga30bdbc77ee2c0b27ee48e5de2654d29c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlFeedbackBufferType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_FEEDBACK_BUFFER_TYPE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_FEEDBACK_BUFFER_TYPE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the type of the feedback buffer. See glFeedbackBuffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_FEEDBACK_BUFFER_TYPE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73b3d82b8c3940a818e1dab3d69e4899"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlFog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_FOG. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_FOG.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether fogging is enabled. The initial value is GL_FALSE. See glFog.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_FOG. </dd></dl>

</div>
</div>
<a class="anchor" id="ga572f199118c8cb77085a7eb21f05f7fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlFogColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_FOG_COLOR. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_FOG_COLOR.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the red, green, blue, and alpha components of the fog color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See glFog.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_FOG_COLOR. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ad8c1de41bc053666ffe001bca8f064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlFogDensity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_FOG_DENSITY. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_FOG_DENSITY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the fog density parameter. The initial value is</p>
<ol type="1">
<li>See glFog.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_FOG_DENSITY. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9c6edbc286eed9a47b2e3ed2426e2b92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlFogEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_FOG_END. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_FOG_END.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the end factor for the linear fog equation. The initial value is 1. See glFog.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_FOG_END. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bd30ecaffe9f7d38e7a447a185dc8d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlFogHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_FOG_HINT. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_FOG_HINT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the mode of the fog hint. The initial value is GL_DONT_CARE. See glHint.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_FOG_HINT. </dd></dl>

</div>
</div>
<a class="anchor" id="ga929e0d580e014af6abda36f16fce43c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlFogIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_FOG_INDEX. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_FOG_INDEX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the fog color index. The initial value is 0. See glFog.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_FOG_INDEX. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f28b3ec34f9bd4a2080e1252ca64d57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlFogMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_FOG_MODE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_FOG_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating which fog equation is selected. The initial value is GL_EXP. See glFog.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_FOG_MODE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7063764912254ec440429aee9e8c3f83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlFogStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_FOG_START. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_FOG_START.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the start factor for the linear fog equation. The initial value is 0. See glFog.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_FOG_START. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5843f630d530a2112407e19b540e3c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlFrontFace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_FRONT_FACE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_FRONT_FACE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating whether clockwise or counterclockwise polygon winding is treated as front-facing. The initial value is GL_CCW. See glFrontFace.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_FRONT_FACE. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb435ce9e5ba38406d8c429a5a0510ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlGreenBias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_GREEN_BIAS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_GREEN_BIAS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the green bias factor used during pixel transfers. The initial value is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_GREEN_BIAS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga418e82a0a01a9dfe598780e602b41b2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlGreenBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_GREEN_BITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_GREEN_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of green bitplanes in each color buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_GREEN_BITS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga933583938ec361ea302f25dd1323b541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlGreenScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_GREEN_SCALE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_GREEN_SCALE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the green scale factor used during pixel transfers. The initial value is 1. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_GREEN_SCALE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga63a264a046b4714154de9f26b04ab1f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlIndexArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_INDEX_ARRAY. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_INDEX_ARRAY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the color index array is enabled. The initial value is GL_FALSE. See glIndexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_INDEX_ARRAY. </dd></dl>

</div>
</div>
<a class="anchor" id="ga79b9f3969a037a0ed02684b41a8a1328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlIndexArrayStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_INDEX_ARRAY_STRIDE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_INDEX_ARRAY_STRIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte offset between consecutive color indexes in the color index array. The initial value is 0. See glIndexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_INDEX_ARRAY_STRIDE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8479c06a3ede7442505bb38803be818f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlIndexArrayType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_INDEX_ARRAY_TYPE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_INDEX_ARRAY_TYPE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the data type of indexes in the color index array. The initial value is GL_FLOAT. See glIndexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_INDEX_ARRAY_TYPE. </dd></dl>

</div>
</div>
<a class="anchor" id="gae88fc4ca05d447c04f08671823a407a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlIndexBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_INDEX_BITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_INDEX_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of bitplanes in each color index buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_INDEX_BITS. </dd></dl>

</div>
</div>
<a class="anchor" id="gad0d02a72c93d1501432001b500bf6435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlIndexClearValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_INDEX_CLEAR_VALUE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_INDEX_CLEAR_VALUE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the color index used to clear the color index buffers. The initial value is 0. See glClearIndex.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_INDEX_CLEAR_VALUE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5294ee67327c1a604fe1ac627d539acc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlIndexLogicOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_INDEX_LOGIC_OP. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_INDEX_LOGIC_OP.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether a fragment's index values are merged into the framebuffer using a logical operation. The initial value is GL_FALSE. See glLogicOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_INDEX_LOGIC_OP. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5413d656a860db0103e85dcd025970e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlIndexMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_INDEX_MODE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_INDEX_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the GL is in color index mode (GL_TRUE) or RGBA mode (GL_FALSE).</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_INDEX_MODE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ef77a1752dfc7df305e66d9ebc8fee0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlIndexOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_INDEX_OFFSET. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_INDEX_OFFSET.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the offset added to color and stencil indices during pixel transfers. The initial value is 0. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_INDEX_OFFSET. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb665544045af095c7c301467b71a53d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlIndexShift </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_INDEX_SHIFT. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_INDEX_SHIFT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the amount that color and stencil indices are shifted during pixel transfers. The initial value is 0. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_INDEX_SHIFT. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7041e09cfd847b59e2fd8b306639b2e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlIndexWritemask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_INDEX_WRITEMASK. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_INDEX_WRITEMASK.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a mask indicating which bitplanes of each color index buffer can be written. The initial value is all 1's. See glIndexMask.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_INDEX_WRITEMASK. </dd></dl>

</div>
</div>
<a class="anchor" id="ga373300784f0f42aea9a0d6c78cb01623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLighti </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LIGHTi. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LIGHTi.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the specified light is enabled. The initial value is GL_FALSE. See glLight and glLightModel.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LIGHTi. </dd></dl>

</div>
</div>
<a class="anchor" id="gac26fe35af4bad0a50b4890f21e61ea02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLighting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LIGHTING. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LIGHTING.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether lighting is enabled. The initial value is GL_FALSE. See glLightModel.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LIGHTING. </dd></dl>

</div>
</div>
<a class="anchor" id="gafee564b101971fe6c901050b13522dc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLightModelAmbient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LIGHT_MODEL_AMBIENT. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LIGHT_MODEL_AMBIENT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the red, green, blue, and alpha components of the ambient intensity of the entire scene. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0.2, 0.2, 0.2, 1.0). See glLightModel.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LIGHT_MODEL_AMBIENT. </dd></dl>

</div>
</div>
<a class="anchor" id="gad3dbc66405e9f773549840afceebda51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLightModelLocalViewer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LIGHT_MODEL_LOCAL_VIEWER. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LIGHT_MODEL_LOCAL_VIEWER.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether specular reflection calculations treat the viewer as being local to the scene. The initial value is GL_FALSE. See glLightModel.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LIGHT_MODEL_LOCAL_VIEWER. </dd></dl>

</div>
</div>
<a class="anchor" id="gab355049dd400e05dcf9057355f954b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLightModelTwoSide </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LIGHT_MODEL_TWO_SIDE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LIGHT_MODEL_TWO_SIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether separate materials are used to compute lighting for front- and back-facing polygons. The initial value is GL_FALSE. See glLightModel.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LIGHT_MODEL_TWO_SIDE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3823c538863f06203e0f72df0af8e517"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLineSmooth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LINE_SMOOTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LINE_SMOOTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether antialiasing of lines is enabled. The initial value is GL_FALSE. See glLineWidth.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LINE_SMOOTH. </dd></dl>

</div>
</div>
<a class="anchor" id="ga259303d6900794169347807035689bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLineSmoothHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LINE_SMOOTH_HINT. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LINE_SMOOTH_HINT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the mode of the line antialiasing hint. The initial value is GL_DONT_CARE. See glHint.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LINE_SMOOTH_HINT. </dd></dl>

</div>
</div>
<a class="anchor" id="gae6a2fafc56ddcffeb516c7e7451ee620"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLineStipple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LINE_STIPPLE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LINE_STIPPLE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether stippling of lines is enabled. The initial value is GL_FALSE. See glLineStipple.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LINE_STIPPLE. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5594a01ce0e3ce08073c9d8adc2dc7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLineStipplePattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LINE_STIPPLE_PATTERN. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LINE_STIPPLE_PATTERN.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the 16-bit line stipple pattern. The initial value is all 1's. See glLineStipple.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LINE_STIPPLE_PATTERN. </dd></dl>

</div>
</div>
<a class="anchor" id="gab9b326741292e41732d5e0b646c4f006"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLineStippleRepeat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LINE_STIPPLE_REPEAT. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LINE_STIPPLE_REPEAT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the line stipple repeat factor. The initial value is 1. See glLineStipple.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LINE_STIPPLE_REPEAT. </dd></dl>

</div>
</div>
<a class="anchor" id="gacd329652ea9f177db0c0ad44bc9150bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLineWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LINE_WIDTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LINE_WIDTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the line width as specified with glLineWidth. The initial value is 1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LINE_WIDTH. </dd></dl>

</div>
</div>
<a class="anchor" id="ga42e5a43f490a0f90bedf54064921de10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLineWidthGranularity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LINE_WIDTH_GRANULARITY. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LINE_WIDTH_GRANULARITY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the width difference between adjacent supported widths for antialiased lines. See glLineWidth.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LINE_WIDTH_GRANULARITY. </dd></dl>

</div>
</div>
<a class="anchor" id="gacdf3e63f9464f755958fb682f2a45015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGllineWidthRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LINE_WIDTH_RANGE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LINE_WIDTH_RANGE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: the smallest and largest supported widths for antialiased lines. See glLineWidth.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LINE_WIDTH_RANGE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga869ac6c34aaec533fb74b4e8095ae993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlListBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LIST_BASE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LIST_BASE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the base offset added to all names in arrays presented to glCallLists. The initial value is 0. See glListBase.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LIST_BASE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4486b4e688ef8a216e16b7c1a6ec7a61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlListIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LIST_INDEX. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LIST_INDEX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the name of the display list currently under construction. 0 is returned if no display list is currently under construction. The initial value is 0. See glNewList.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LIST_INDEX. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75eb73d049c2865922e414f5a06b749a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlListMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LIST_MODE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LIST_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the construction mode of the display list currently under construction. The initial value is 0. See glNewList.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LIST_MODE. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf88292802715427e1a4e58f591b8e67e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlLogicOpMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_LOGIC_OP_MODE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_LOGIC_OP_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the selected logic operation mode. The initial value is GL_COPY. See glLogicOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_LOGIC_OP_MODE. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa3e13a4accbc22c40a52ee9cee9fc3e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap1Color4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP1_COLOR_4. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP1_COLOR_4.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates colors. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP1_COLOR_4. </dd></dl>

</div>
</div>
<a class="anchor" id="gad05cd2af4f512deb88aca0b00b0815c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap1GridDomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP1_GRID_DOMAIN. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP1_GRID_DOMAIN.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: the endpoints of the 1D map's grid domain. The initial value is (0, 1). See glMapGrid.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP1_GRID_DOMAIN. </dd></dl>

</div>
</div>
<a class="anchor" id="gaef4171a2ed92756d394ed8bae1fc57cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap1GridSegments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP1_GRID_SEGMENTS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP1_GRID_SEGMENTS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of partitions in the 1D map's grid domain. The initial value is 1. See glMapGrid.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP1_GRID_SEGMENTS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga52ba9a6fe299e4342d28baac6a83c769"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap1Index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP1_INDEX. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP1_INDEX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates color indices. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP1_INDEX. </dd></dl>

</div>
</div>
<a class="anchor" id="gad0e75e07ddc5d51e11b4a9b525ee4190"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap1Normal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP1_NORMAL. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP1_NORMAL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates normals. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP1_NORMAL. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf06cacbe0ee8f4fe4a6f56571fb8c27c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap1TextureCoord1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_1. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_1.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates 1D texture coordinates. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_1. </dd></dl>

</div>
</div>
<a class="anchor" id="gade175aafd1123e597959f78fbe04489f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap1TextureCoord2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_2. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_2.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates 2D texture coordinates. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_2. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6690ab58fbdae84d2543e29cc9e4c41d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap1TextureCoord3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_3. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_3.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates 3D texture coordinates. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_3. </dd></dl>

</div>
</div>
<a class="anchor" id="gab7a65aa462c3a278c42977ed9a35904e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap1TextureCoord4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_4. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_4.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates 4D texture coordinates. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP1_TEXTURE_COORD_4. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe0e07682a0bb42bb227fecd287de609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap1Vertex3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP1_VERTEX_3. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP1_VERTEX_3.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates 3D vertex coordinates. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP1_VERTEX_3. </dd></dl>

</div>
</div>
<a class="anchor" id="gab130a35770d4594bf74a89d18c49697a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap1Vertex4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP1_VERTEX_4. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP1_VERTEX_4.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates 4D vertex coordinates. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP1_VERTEX_4. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85dca50f7d25944ca4158173a630d15d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap2Color4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP2_COLOR_4. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP2_COLOR_4.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates colors. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP2_COLOR_4. </dd></dl>

</div>
</div>
<a class="anchor" id="ga15f308a3995cd63e0bf8ff13fd1024dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap2GridDomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP2_GRID_DOMAIN. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP2_GRID_DOMAIN.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the endpoints of the 2D map's i and j grid domains. The initial value is (0,1; 0,1). See glMapGrid.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP2_GRID_DOMAIN. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7cc72b6b6d1f670c6bb2a37bb02f22cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap2GridSegments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP2_GRID_SEGMENTS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP2_GRID_SEGMENTS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: the number of partitions in the 2D map's i and j grid domains. The initial value is (1,1). See glMapGrid.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP2_GRID_SEGMENTS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c26c0fce87b7c852f2819ddbc816835"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap2Index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP2_INDEX. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP2_INDEX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates color indices. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP2_INDEX. </dd></dl>

</div>
</div>
<a class="anchor" id="ga281e64b376bb0c3f7f7090820a64bd7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap2Normal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP2_NORMAL. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP2_NORMAL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates normals. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP2_NORMAL. </dd></dl>

</div>
</div>
<a class="anchor" id="gadb7c67ea193286a4088b9dcc172abef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap2TextureCoord1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_1. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_1.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates 1D texture coordinates. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_1. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5cb23274f1ad4c504c5aed7947a3432"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap2TextureCoord2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_2. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_2.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates 2D texture coordinates. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_2. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4b636ae980e2c420c9a7357fe8d58cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap2TextureCoord3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_3. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_3.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates 3D texture coordinates. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_3. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0716a8c85e544f43620ea6664c58b570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap2TextureCoord4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_4. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_4.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates 4D texture coordinates. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP2_TEXTURE_COORD_4. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d031ab910660e0f56b3ed4a95d2bfc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap2Vertex3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP2_VERTEX_3. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP2_VERTEX_3.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates 3D vertex coordinates. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP2_VERTEX_3. </dd></dl>

</div>
</div>
<a class="anchor" id="ga866e31b0b0469c11f0c0bee0bb4f9973"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMap2Vertex4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP2_VERTEX_4. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP2_VERTEX_4.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates 4D vertex coordinates. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP2_VERTEX_4. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7224b43655a9b3d8a381bea11d42d401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMapColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP_COLOR. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP_COLOR.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating if colors and color indices are to be replaced by table lookup during pixel transfers. The initial value is GL_FALSE. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP_COLOR. </dd></dl>

</div>
</div>
<a class="anchor" id="ga17a6e4887be554b1845d8eb595129b0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMapStencil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAP_STENCIL. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAP_STENCIL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating if stencil indices are to be replaced by table lookup during pixel transfers. The initial value is GL_FALSE. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAP_STENCIL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3cb5f2ef622bebc2786449eda2460d55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMatrixMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MATRIX_MODE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MATRIX_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating which matrix stack is currently the target of all matrix operations. The initial value is GL_MODELVIEW. See glMatrixMode.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MATRIX_MODE. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa03eca9a37a755a11183714292f89779"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxAttribStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_ATTRIB_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_ATTRIB_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum supported depth of the attribute stack. The value must be at least 16. See glPushAttrib.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_ATTRIB_STACK_DEPTH. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2085416ccd06cb60bc98ba2207174dd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxClientAttribStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_CLIENT_ATTRIB_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_CLIENT_ATTRIB_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value indicating the maximum supported depth of the client attribute stack. See glPushClientAttrib.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_CLIENT_ATTRIB_STACK_DEPTH. </dd></dl>

</div>
</div>
<a class="anchor" id="gae90d5285df064d711bedd09091ba413b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxClipPlanes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_CLIP_PLANES. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_CLIP_PLANES.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum number of application-defined clipping planes. The value must be at least 6. See glClipPlane.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_CLIP_PLANES. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf82e6892182ffe565a05329073a06248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxEvalOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_EVAL_ORDER. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_EVAL_ORDER.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum equation order supported by 1D and 2D evaluators. The value must be at least 8. See glMap1 and glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_EVAL_ORDER. </dd></dl>

</div>
</div>
<a class="anchor" id="ga95b23ba66220abe4def913fd80f31f9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxLights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_LIGHTS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_LIGHTS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum number of lights. The value must be at least 8. See glLight.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_LIGHTS. </dd></dl>

</div>
</div>
<a class="anchor" id="gaab626bdfc4cf8d6445955270799c969a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxListNesting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_LIST_NESTING. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_LIST_NESTING.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum recursion depth allowed during display-list traversal. The value must be at least 64. See glCallList.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_LIST_NESTING. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a7a64fd525a66dfc542f8d38470e6df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxModelviewStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_MODELVIEW_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_MODELVIEW_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum supported depth of the modelview matrix stack. The value must be at least 32. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_MODELVIEW_STACK_DEPTH. </dd></dl>

</div>
</div>
<a class="anchor" id="gad22c079b7e29e5cfb6ee2fe9bb220816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxNameStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_NAME_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_NAME_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum supported depth of the selection name stack. The value must be at least 64. See glPushName.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_NAME_STACK_DEPTH. </dd></dl>

</div>
</div>
<a class="anchor" id="ga266533ff4a35f65c19be95594d07f435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxPixelMapTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_PIXEL_MAP_TABLE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_PIXEL_MAP_TABLE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum supported size of a glPixelMap lookup table. The value must be at least 32. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_PIXEL_MAP_TABLE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c2d3530aa09867d9c01d8433839011e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxProjectionStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_PROJECTION_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_PROJECTION_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum supported depth of the projection matrix stack. The value must be at least 2. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_PROJECTION_STACK_DEPTH. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeba7eaad6682c2c4aa8925501601c606"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxTextureSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_TEXTURE_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_TEXTURE_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value. The value gives a rough estimate of the largest texture that the GL can handle. If the GL version is 1.1 or greater, use GL_PROXY_TEXTURE_1D or GL_PROXY_TEXTURE_2D to determine if a texture is too large. See glTexImage1D and glTexImage2D.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_TEXTURE_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9aac1a0891487831a30125fca75bec93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxTextureStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_TEXTURE_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_TEXTURE_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum supported depth of the texture matrix stack. The value must be at least 2. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_TEXTURE_STACK_DEPTH. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0dad12ef08cd32b9fb94e214f00a95a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlMaxViewportDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MAX_VIEWPORT_DIMS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MAX_VIEWPORT_DIMS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: the maximum supported width and height of the viewport. These must be at least as large as the visible dimensions of the display being rendered to. See glViewport.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MAX_VIEWPORT_DIMS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga44c62c93a914527f821b2aef913fada7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlModelviewMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MODELVIEW_MATRIX. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MODELVIEW_MATRIX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns sixteen values: the modelview matrix on the top of the modelview matrix stack. Initially this matrix is the identity matrix. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MODELVIEW_MATRIX. </dd></dl>

</div>
</div>
<a class="anchor" id="ga745672a8704edbf33daef5314f9cdfaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlModelviewStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_MODELVIEW_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_MODELVIEW_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of matrices on the modelview matrix stack. The initial value is 1. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_MODELVIEW_STACK_DEPTH. </dd></dl>

</div>
</div>
<a class="anchor" id="ga04c7aa5d2e684fa0029e53b8c3b2cda8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlNameStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_NAME_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_NAME_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of names on the selection name stack. The initial value is 0. See glPushName.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_NAME_STACK_DEPTH. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa71b4ce64f1a5f86f8822904e51b549f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlNormalArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_NORMAL_ARRAY. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_NORMAL_ARRAY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value, indicating whether the normal array is enabled. The initial value is GL_FALSE. See glNormalPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_NORMAL_ARRAY. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9388bcac733bb55d8bff349828b9d86d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlNormalArrayStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_NORMAL_ARRAY_STRIDE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_NORMAL_ARRAY_STRIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte offset between consecutive normals in the normal array. The initial value is 0. See glNormalPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_NORMAL_ARRAY_STRIDE. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2ac905eb6421d2ff8edb736557f40e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlNormalArrayType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_NORMAL_ARRAY_TYPE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_NORMAL_ARRAY_TYPE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the data type of each coordinate in the normal array. The initial value is GL_FLOAT. See glNormalPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_NORMAL_ARRAY_TYPE. </dd></dl>

</div>
</div>
<a class="anchor" id="gab8f8c7f8e749817f94751308b2344af4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlNormalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_NORMALIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_NORMALIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether normals are automatically scaled to unit length after they have been transformed to eye coordinates. The initial value is GL_FALSE. See glNormal.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_NORMALIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b46757dfa6068f0833baab8d98d2c2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPackAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PACK_ALIGNMENT. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PACK_ALIGNMENT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte alignment used for writing pixel data to memory. The initial value is 4. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PACK_ALIGNMENT. </dd></dl>

</div>
</div>
<a class="anchor" id="ga49cc9b47a26f144e0651b4679752a02c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPackLsbFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PACK_LSB_FIRST. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PACK_LSB_FIRST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. The initial value is GL_FALSE. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PACK_LSB_FIRST. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64b0337d0f84557f6f8661ec6e03e154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPackRowLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PACK_ROW_LENGTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PACK_ROW_LENGTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the row length used for writing pixel data to memory. The initial value is 0. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PACK_ROW_LENGTH. </dd></dl>

</div>
</div>
<a class="anchor" id="gadb44f6347d29047a0a3789c51f4913f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPackSkipPixels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PACK_SKIP_PIXELS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PACK_SKIP_PIXELS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PACK_SKIP_PIXELS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga13b70d48642c0b921c0497f1ed7e88fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPackSkipRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PACK_SKIP_ROWS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PACK_SKIP_ROWS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of rows of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PACK_SKIP_ROWS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34c8e9bce5b0b759995934900bc33e14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPackSwapBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PACK_SWAP_BYTES. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PACK_SWAP_BYTES.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped before being written to memory. The initial value is GL_FALSE. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PACK_SWAP_BYTES. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f8a371d540a654c038ff2e3301a63d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPerspectiveCorrectionHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PERSPECTIVE_CORRECTION_HINT. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PERSPECTIVE_CORRECTION_HINT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the mode of the perspective correction hint. The initial value is GL_DONT_CARE. See glHint.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PERSPECTIVE_CORRECTION_HINT. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d92a97f95de6e5eb298d27c342a4375"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPixelMapAToASize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PIXEL_MAP_A_TO_A_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PIXEL_MAP_A_TO_A_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the alpha-to-alpha pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PIXEL_MAP_A_TO_A_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga554e72e1ef666b6dca527a1073219c9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPixelMapBToBSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PIXEL_MAP_B_TO_B_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PIXEL_MAP_B_TO_B_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the blue-to-blue pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PIXEL_MAP_B_TO_B_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="gad80ac227ca04522df384be1e0f93b546"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPixelMapGToGSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PIXEL_MAP_G_TO_G_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PIXEL_MAP_G_TO_G_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the green-to-green pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PIXEL_MAP_G_TO_G_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="gadadb89e110f09aaf815829f028ab539d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPixelMapIToASize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_A_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_A_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the index-to-alpha pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_A_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fac55d9d77a0b119c7247536471b5fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPixelMapIToBSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_B_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_B_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the index-to-blue pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_B_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa449af86fad19dad37eea16a918b3c33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPixelMapIToGSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_G_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_G_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the index-to-green pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_G_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0eb7b39aef0ca240d98e9507703cd1e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPixelMapIToISize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_I_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_I_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the index-to-index pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_I_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="gad3cc6e9acee4df62ca1407e6b42d87d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPixelMapIToRSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_R_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_R_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the index-to-red pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PIXEL_MAP_I_TO_R_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga315fd9fa34e26c259ce76e33ddadc11b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPixelMapRToRSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PIXEL_MAP_R_TO_R_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PIXEL_MAP_R_TO_R_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the red-to-red pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PIXEL_MAP_R_TO_R_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d77ae2d820ab8304af841033ee957ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPixelMapSToSSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PIXEL_MAP_S_TO_S_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PIXEL_MAP_S_TO_S_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the stencil-to-stencil pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PIXEL_MAP_S_TO_S_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="gad02efc6cfc989e454b9cc91443fef303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPointSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POINT_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POINT_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the point size as specified by glPointSize. The initial value is 1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POINT_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga77ea6a1da567197d644dcd11743f67a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPointSizeGranularity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POINT_SIZE_GRANULARITY. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POINT_SIZE_GRANULARITY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size difference between adjacent supported sizes for antialiased points. See glPointSize.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POINT_SIZE_GRANULARITY. </dd></dl>

</div>
</div>
<a class="anchor" id="gab2553c47e6d7fa315b61ab5dcdb1506e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPointSizeRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POINT_SIZE_RANGE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POINT_SIZE_RANGE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: the smallest and largest supported sizes for antialiased points. The smallest size must be at most 1, and the largest size must be at least 1. See glPointSize.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POINT_SIZE_RANGE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga32e178d5d54d00dc20f27cf516943a65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPointSmooth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POINT_SMOOTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POINT_SMOOTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether antialiasing of points is enabled. The initial value is GL_FALSE. See glPointSize.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POINT_SMOOTH. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9c02409795d34b851b6da29f7f91c35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPointSmoothHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POINT_SMOOTH_HINT. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POINT_SMOOTH_HINT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the mode of the point antialiasing hint. The initial value is GL_DONT_CARE. See glHint.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POINT_SMOOTH_HINT. </dd></dl>

</div>
</div>
<a class="anchor" id="ga799784d6a719eb2c25ffd5854ec09aa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPolygonMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POLYGON_MODE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POLYGON_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: symbolic constants indicating whether front-facing and back-facing polygons are rasterized as points, lines, or filled polygons. The initial value is GL_FILL. See glPolygonMode.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POLYGON_MODE. </dd></dl>

</div>
</div>
<a class="anchor" id="gaedc33f5a28be70057bb4b6124b67955a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPolygonOffsetFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_FACTOR. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_FACTOR.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See glPolygonOffset.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POLYGON_OFFSET_FACTOR. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4f958b650aeedc92140b1406f98d985"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPolygonOffsetFill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_FILL. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_FILL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether polygon offset is enabled for polygons in fill mode. The initial value is GL_FALSE. See glPolygonOffset.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POLYGON_OFFSET_FILL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7470a404bbcbef21d1316b3bfd02deb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPolygonOffsetLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_LINE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_LINE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether polygon offset is enabled for polygons in line mode. The initial value is GL_FALSE. See glPolygonOffset.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POLYGON_OFFSET_LINE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga19543110e1a7115a1ec9a30caaa490fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPolygonOffsetPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_POINT. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_POINT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether polygon offset is enabled for polygons in point mode. The initial value is GL_FALSE. See glPolygonOffset.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POLYGON_OFFSET_POINT. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e5f7eacf5333293ba0f1a02bbe3cdc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPolygonOffsetUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_UNITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POLYGON_OFFSET_UNITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See glPolygonOffset.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POLYGON_OFFSET_UNITS. </dd></dl>

</div>
</div>
<a class="anchor" id="gac4627c5f84f92d1e259d756aba7d6068"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPolygonSmooth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POLYGON_SMOOTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POLYGON_SMOOTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether antialiasing of polygons is enabled. The initial value is GL_FALSE. See glPolygonMode.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POLYGON_SMOOTH. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45100a9646aab1c37b538298c55cb0ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPolygonSmoothHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POLYGON_SMOOTH_HINT. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POLYGON_SMOOTH_HINT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the mode of the polygon antialiasing hint. The initial value is GL_DONT_CARE. See glHint.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POLYGON_SMOOTH_HINT. </dd></dl>

</div>
</div>
<a class="anchor" id="ga53fd366a5e9d6eef773c883b1d2914d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlPolygonStipple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_POLYGON_STIPPLE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_POLYGON_STIPPLE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether polygon stippling is enabled. The initial value is GL_FALSE. See glPolygonStipple.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_POLYGON_STIPPLE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e56c1c62378ae9385db874bf2b6a030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlProjectionMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PROJECTION_MATRIX. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PROJECTION_MATRIX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns sixteen values: the projection matrix on the top of the projection matrix stack. Initially this matrix is the identity matrix. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PROJECTION_MATRIX. </dd></dl>

</div>
</div>
<a class="anchor" id="gad2d5e19c001663ff2943c43cc9b0c0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlProjectionStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_PROJECTION_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_PROJECTION_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of matrices on the projection matrix stack. The initial value is 1. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_PROJECTION_STACK_DEPTH. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d3a759c6f7b623d7598708ca4810b00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlReadBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_READ_BUFFER. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_READ_BUFFER.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating which color buffer is selected for reading. The initial value is GL_BACK if there is a back buffer, otherwise it is GL_FRONT. See glReadPixels and glAccum.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_READ_BUFFER. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4db73eaaf942ff5c5aa9b62e0386f9a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlRedBias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_RED_BIAS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_RED_BIAS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the red bias factor used during pixel transfers. The initial value is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_RED_BIAS. </dd></dl>

</div>
</div>
<a class="anchor" id="gac4060a4139d031b9f8b9b1198c4a89f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlRedBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_RED_BITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_RED_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of red bitplanes in each color buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_RED_BITS. </dd></dl>

</div>
</div>
<a class="anchor" id="gae20713f3668cb6be662849b8de30d623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlRedScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_RED_SCALE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_RED_SCALE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the red scale factor used during pixel transfers. The initial value is 1. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_RED_SCALE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64d9bf10216007aeb301d43ac14f82b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlRenderMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_RENDER_MODE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_RENDER_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating whether the GL is in render, select, or feedback mode. The initial value is GL_RENDER. See glRenderMode.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_RENDER_MODE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1596849dfe7b4606e0fc3ff9fbe00489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlRgbaMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_RGBA_MODE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_RGBA_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the GL is in RGBA mode (true) or color index mode (false). See glColor.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_RGBA_MODE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga58f683f150a231ec839aed3f79cd3ef2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlScissorBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_SCISSOR_BOX. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_SCISSOR_BOX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the x and y window coordinates of the scissor box, followed by its width and height. Initially the x and y window coordinates are both 0 and the width and height are set to the size of the window. See glScissor.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_SCISSOR_BOX. </dd></dl>

</div>
</div>
<a class="anchor" id="ga80ed5d63c763521b6db8166033008a6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlScissorTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_SCISSOR_TEST. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_SCISSOR_TEST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether scissoring is enabled. The initial value is GL_FALSE. See glScissor.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_SCISSOR_TEST. </dd></dl>

</div>
</div>
<a class="anchor" id="gae47f276d2d1d8233f544fca09b062e63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlSelectionBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_SELECTION_BUFFER_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_SELECTION_BUFFER_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params return one value, the size of the selection buffer. See glSelectBuffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_SELECTION_BUFFER_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="gaef3c863fd714bcd6607a7fe129c6c1d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlShadeModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_SHADE_MODEL. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_SHADE_MODEL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating whether the shading mode is flat or smooth. The initial value is GL_SMOOTH. See glShadeModel.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_SHADE_MODEL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9001f71cc6ac9cb771d5e9eeedd69c5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlStencilBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_STENCIL_BITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_STENCIL_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of bitplanes in the stencil buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_STENCIL_BITS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0949a92c39c09a594a65cb035d992baf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlStencilClearValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_STENCIL_CLEAR_VALUE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_STENCIL_CLEAR_VALUE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the index to which the stencil bitplanes are cleared. The initial value is 0. See glClearStencil.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_STENCIL_CLEAR_VALUE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3022225d3598456c739303b98e9d6ff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlStencilFail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_STENCIL_FAIL. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_STENCIL_FAIL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating what action is taken when the stencil test fails. The initial value is GL_KEEP. See glStencilOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_STENCIL_FAIL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1afa1d486d88c628562ec9e9ba6f6e10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlStencilFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_STENCIL_FUNC. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_STENCIL_FUNC.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. The initial value is GL_ALWAYS. See glStencilFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_STENCIL_FUNC. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e0217d78bce7c9e8aa865fa1b2d7e1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlStencilPassDepthFail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_STENCIL_PASS_DEPTH_FAIL. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_STENCIL_PASS_DEPTH_FAIL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. The initial value is GL_KEEP. See glStencilOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_STENCIL_PASS_DEPTH_FAIL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga722cf069559981c09c4b40810b37986f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlStencilPassDepthPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_STENCIL_PASS_DEPTH_PASS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_STENCIL_PASS_DEPTH_PASS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. The initial value is GL_KEEP. See glStencilOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_STENCIL_PASS_DEPTH_PASS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga31c961d29726d9daaf4d7cfc78025a6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlStencilRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_STENCIL_REF. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_STENCIL_REF.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the reference value that is compared with the contents of the stencil buffer. The initial value is 0. See glStencilFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_STENCIL_REF. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c3fb4e59ed994063e62893114882ad7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlStencilTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_STENCIL_TEST. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_STENCIL_TEST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether stencil testing of fragments is enabled. The initial value is GL_FALSE. See glStencilFunc and glStencilOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_STENCIL_TEST. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88f72c76847937fa57511a7758f43d43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlStencilValueMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_STENCIL_VALUE_MASK. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_STENCIL_VALUE_MASK.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See glStencilFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_STENCIL_VALUE_MASK. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4dbeac5dc5d9ad85a54af632e3f96aac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlStencilWritemask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_STENCIL_WRITEMASK. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_STENCIL_WRITEMASK.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the mask that controls writing of the stencil bitplanes. The initial value is all 1's. See glStencilMask.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_STENCIL_WRITEMASK. </dd></dl>

</div>
</div>
<a class="anchor" id="gadb2e39bc8896bcdd38587b23347df156"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlStereo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_STEREO. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_STEREO.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether stereo buffers (left and right) are supported.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_STEREO. </dd></dl>

</div>
</div>
<a class="anchor" id="ga842fdba84c1a6dc5261e2e694732df1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlSubpixelBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_SUBPIXEL_BITS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_SUBPIXEL_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates. The initial value is 4.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_SUBPIXEL_BITS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60712e8970d469ba28a61541933011c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTexture1D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_1D. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_1D.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D texture mapping is enabled. The initial value is GL_FALSE. See glTexImage1D.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_1D. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9c4d303e8a354ddb4678796eaceb45c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTexture2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_2D. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_2D.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D texture mapping is enabled. The initial value is GL_FALSE. See glTexImage2D.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_2D. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ef71bae62c28f023f69aa0838ef1b31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTextureBinding1D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_BINDING_1D. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_BINDING_1D.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single value, the name of the texture currently bound to the target GL_TEXTURE_1D. The initial value is 0. See glBindTexture.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_BINDING_1D. </dd></dl>

</div>
</div>
<a class="anchor" id="ga308bae30bed330cc281e0f2443cb43d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTextureBinding2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_BINDING_2D. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_BINDING_2D.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single value, the name of the texture currently bound to the target GL_TEXTURE_2D. The initial value is 0. See glBindTexture.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_BINDING_2D. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e3e42a091a09f20c4885d62bd29d1fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTextureCoordArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the texture coordinate array is enabled. The initial value is GL_FALSE. See glTexCoordPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY. </dd></dl>

</div>
</div>
<a class="anchor" id="ga874c08bb1dab5bf56279fa496f347017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTextureCoordArraySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of coordinates per element in the texture coordinate array. The initial value is 4. See glTexCoordPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cef5f78ea9815fc83b519aff2694d5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTextureCoordArrayStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY_STRIDE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY_STRIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte offset between consecutive elements in the texture coordinate array. The initial value is 0. See glTexCoordPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY_STRIDE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6cae6d3addddcf37939f5543fffab86f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTextureCoordArrayType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY_TYPE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY_TYPE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the data type of the coordinates in the texture coordinate array. The initial value is GL_FLOAT. See glTexCoordPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_COORD_ARRAY_TYPE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2bc696d575361d0668e25ab8f8455c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTextureGenQ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_GEN_Q. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_GEN_Q.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether automatic generation of the q texture coordinate is enabled. The initial value is GL_FALSE. See glTexGen.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_GEN_Q. </dd></dl>

</div>
</div>
<a class="anchor" id="ga232ca6071605477892ccd38781f48b53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTextureGenR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_GEN_R. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_GEN_R.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether automatic generation of the r texture coordinate is enabled. The initial value is GL_FALSE. See glTexGen.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_GEN_R. </dd></dl>

</div>
</div>
<a class="anchor" id="gac92ef30b356fe2de552d88b455aa0b20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTextureGenS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_GEN_S. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_GEN_S.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether automatic generation of the S texture coordinate is enabled. The initial value is GL_FALSE. See glTexGen.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_GEN_S. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa225300590e106cd32d3a011d1ff6599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTextureGenT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_GEN_T. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_GEN_T.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether automatic generation of the T texture coordinate is enabled. The initial value is GL_FALSE. See glTexGen.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_GEN_T. </dd></dl>

</div>
</div>
<a class="anchor" id="gad21a2e048b745fe84c5befbd361f2f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTextureMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_MATRIX. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_MATRIX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns sixteen values: the texture matrix on the top of the texture matrix stack. Initially this matrix is the identity matrix. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_MATRIX. </dd></dl>

</div>
</div>
<a class="anchor" id="ga278f05112b89edd0cbb3d601d73fadb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlTextureStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_TEXTURE_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_TEXTURE_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of matrices on the texture matrix stack. The initial value is 1. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_TEXTURE_STACK_DEPTH. </dd></dl>

</div>
</div>
<a class="anchor" id="gabcc3fe54f0a5f429af71e1bacef5a9c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlUnpackAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_UNPACK_ALIGNMENT. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_UNPACK_ALIGNMENT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte alignment used for reading pixel data from memory. The initial value is 4. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_UNPACK_ALIGNMENT. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5de4612f68058b5bc47576fc64f97004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlUnpackLsbFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_UNPACK_LSB_FIRST. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_UNPACK_LSB_FIRST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. The initial value is GL_FALSE. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_UNPACK_LSB_FIRST. </dd></dl>

</div>
</div>
<a class="anchor" id="gaefbf6604571a413d33c117cb1c170a79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlUnpackRowLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_UNPACK_ROW_LENGTH. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_UNPACK_ROW_LENGTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the row length used for reading pixel data from memory. The initial value is 0. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_UNPACK_ROW_LENGTH. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0abd9dc2b1158d657d9553424732bb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlUnpackSkipPixels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_UNPACK_SKIP_PIXELS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_UNPACK_SKIP_PIXELS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_UNPACK_SKIP_PIXELS. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4065b05943d7e949fd785f85dd3cdc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlUnpackSkipRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_UNPACK_SKIP_ROWS. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_UNPACK_SKIP_ROWS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of rows of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_UNPACK_SKIP_ROWS. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9b797c3176f4a4cb2094550ebaab4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlUnpackSwapBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_UNPACK_SWAP_BYTES. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_UNPACK_SWAP_BYTES.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped after being read from memory. The initial value is GL_FALSE. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_UNPACK_SWAP_BYTES. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa758212d7a3f274415edbc9e2532289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlVertexArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_VERTEX_ARRAY. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_VERTEX_ARRAY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the vertex array is enabled. The initial value is GL_FALSE. See glVertexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_VERTEX_ARRAY. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5475c8155f182e7c018cca2f6124f746"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlVertexArraySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_VERTEX_ARRAY_SIZE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_VERTEX_ARRAY_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of coordinates per vertex in the vertex array. The initial value is 4. See glVertexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_VERTEX_ARRAY_SIZE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7830e4ba0be698e54d824a5c6a430f5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlVertexArrayStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_VERTEX_ARRAY_STRIDE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_VERTEX_ARRAY_STRIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte offset between consecutive vertices in the vertex array. The initial value is 0. See glVertexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_VERTEX_ARRAY_STRIDE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga27df79ce6a4279f818c5cd041e8dc6bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlVertexArrayType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_VERTEX_ARRAY_TYPE. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_VERTEX_ARRAY_TYPE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the data type of each coordinate in the vertex array. The initial value is GL_FLOAT. See glVertexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_VERTEX_ARRAY_TYPE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6afc9840c8a03deb6d741843bf82d28d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlViewport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_VIEWPORT. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_VIEWPORT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the x and y window coordinates of the viewport, followed by its width and height. Initially the x and y window coordinates are both set to 0, and the width and height are set to the width and height of the window into which the GL will do its rendering. See glViewport.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_VIEWPORT. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ca35baf35a77d201c5a770a22aedbe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlZoomX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ZOOM_X. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ZOOM_X.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the x pixel zoom factor. The initial value is 1. See glPixelZoom.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ZOOM_X. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4231723bc8a26f191c53329dceed9222"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> EtatOpenGL::obtenirChaineGlZoomY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne representant l'attribut GL_ZOOM_Y. </p>
<p>Cette fonction retourne une chaîne representant l'attribut GL_ZOOM_Y.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the $y$ pixel zoom factor. The initial value is</p>
<ol type="1">
<li>See glPixelZoom.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne representant l'attribut GL_ZOOM_Y. </dd></dl>

</div>
</div>
<a class="anchor" id="ga24ddfdab3e65cc4069b86ba84d3f565b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="wglew_8h.html#aeea6e3dfae3acf232096f57d2d57f084">void</a> EtatOpenGL::obtenirDifference </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a> &amp;&#160;</td>
          <td class="paramname"><em>etat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a> &amp;&#160;</td>
          <td class="paramname"><em>etat2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare deux etats OpenGL et affiche la difference entre les deux. </p>
<p>Cet operateur permet d'afficher l'etat OpenGL sous une forme lisible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>: Le flux de sortie. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etat1</td><td>: Le premier etat OpenGL de la comparaison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etat2</td><td>: Le second etat OpenGL de la comparaison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Le flux de sortie. </dd></dl>

</div>
</div>
<a class="anchor" id="ga349c289d77c484b8b4a180843d968b46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_singleton.html">Singleton</a>&lt; T &gt;::obtenirInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtient l'instance unique de la classe. </p>
<p>Cette fonction retourne l'instance unique de la classe. Si l'instance n'existe pas, elle est creee. Ainsi, une seule instance sera creee. Cette fonction n'est pas "thread-safe".</p>
<dl class="section return"><dt>Returns</dt><dd>L'instance unique de la classe. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3eb1e87955cdb70cd0b16f217740326b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &lt; pour une variable de type <em>std::string</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: La variable de type <em>std::string</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="ga04922202c65ecfea992b139fa3ad19ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &lt; pour une variable de type <em>double</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: La variable de type <em>double</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="ga616de7f95d66959d1a2e3216143180aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="fmod_8h.html#aeb841aa4b4b5f444b5d739d865b420af">float</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &lt; pour une variable de type <em>float</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: La variable de type <em>float</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c0af1c4869b15575ea9c9567a377776"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &lt; pour une variable de type <em>int</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: La variable de type <em>int</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4c96e2902dbd2e7fc766683ae7dd3a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_free_image_8h.html#a425076c7067a1b5166e2cc530e914814">unsigned</a> <a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &lt; pour une variable de type <em>unsigned</em> <em>int</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: La variable de type <em>unsigned</em> <em>int</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2df50a83cca6bbfec35053d1b3f08a83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &lt; pour une variable de type <em>char</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: La variable de type <em>char</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e7baf907cb1eec95df25008219c34f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &lt; pour une variable de type <em>bool</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: La variable de type <em>bool</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="ga07715cf8ba84aab7a025770804188a24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a> &amp;&#160;</td>
          <td class="paramname"><em>etat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cet operateur permet d'afficher l'etat OpenGL sous une forme lisible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>: Le flux de sortie. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etat</td><td>: L'etat OpenGL a afficher.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Le flux de sortie. </dd></dl>

</div>
</div>
<a class="anchor" id="ga810bf15b405f05f3069b97084f61aa95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="glew_8h.html#ae84541b4f3d8e1ea24ec0f466a8c568b">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &gt; pour une variable de type <em>std::string</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>: La variable de type <em>std:string</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3286b1bfce354ab81b9c5e16318f3726"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &gt; pour une variable de type <em>double</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: La variable de type <em>double</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="ga66a0bc917393930593341bc27a7fa51d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fmod_8h.html#aeb841aa4b4b5f444b5d739d865b420af">float</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &gt; pour une variable de type <em>float</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: La variable de type <em>float</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="ga06cd33d9234f45523dd443b122d897fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &gt; pour une variable de type <em>int</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: La variable de type <em>int</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf02d6718459c6e38d1ef0350b209da02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_free_image_8h.html#a425076c7067a1b5166e2cc530e914814">unsigned</a> <a class="el" href="wglew_8h.html#a500a82aecba06f4550f6849b8099ca21">int</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &gt; pour une variable de type <em>unsigned</em> <em>int</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: La variable de type <em>unsigned</em> <em>int</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="ga81285ae431b1fa84429945395a36f8ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &gt; pour une variable de type <em>char</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: La variable de type <em>char</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1585cce945bae21c66998f92f175b115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'operateur &gt; pour une variable de type <em>bool</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: L'objet representant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: La variable de type <em>bool</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet representant le fichier binaire. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 24 2014 23:31:32 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
